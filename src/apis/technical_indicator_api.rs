/*
 * Twelve Data API
 *
 * ## Overview  Welcome to Twelve Data developer docs — your gateway to comprehensive financial market data through a powerful and easy-to-use API. Twelve Data provides access to financial markets across over 50 global countries, covering more than 1 million public instruments, including stocks, forex, ETFs, mutual funds, commodities, and cryptocurrencies.  ## Quickstart  To get started, you'll need to sign up for an API key. Once you have your API key, you can start making requests to the API.  ### Step 1: Create Twelve Data account  Sign up on the Twelve Data website to create your account [here](https://twelvedata.com/register). This gives you access to the API dashboard and your API key.  ### Step 2: Get your API key  After signing in, navigate to your [dashboard](https://twelvedata.com/account/api-keys) to find your unique API key. This key is required to authenticate all API and WebSocket requests.  ### Step 3: Make your first request  Try a simple API call with cURL to fetch the latest price for Apple (AAPL):  ``` curl \"https://api.twelvedata.com/price?symbol=AAPL&apikey=your_api_key\" ```  ### Step 4: Make a request from Python or Javascript  Use our client libraries or standard HTTP clients to make API calls programmatically. Here’s an example in [Python](https://github.com/twelvedata/twelvedata-python) and JavaScript:  #### Python (using official Twelve Data SDK):  ```python from twelvedata import TDClient  # Initialize client with your API key td = TDClient(apikey=\"your_api_key\")  # Get latest price for Apple price = td.price(symbol=\"AAPL\").as_json()  print(price) ```  #### JavaScript (Node.js):  ```javascript const fetch = require('node-fetch');  fetch('https://api.twelvedata.com/price?symbol=AAPL&apikey=your_api_key') &nbsp;&nbsp;.then(response => response.json()) &nbsp;&nbsp;.then(data => console.log(data)); ```  ### Step 5: Perform correlation analysis between Tesla and Microsoft prices  Fetch historical price data for Tesla (TSLA) and Microsoft (MSFT) and calculate the correlation of their closing prices:  ```python from twelvedata import TDClient import pandas as pd  # Initialize client with your API key td = TDClient(apikey=\"your_api_key\")  # Fetch historical price data for Tesla tsla_ts = td.time_series( &nbsp;&nbsp;&nbsp;&nbsp;symbol=\"TSLA\", &nbsp;&nbsp;&nbsp;&nbsp;interval=\"1day\", &nbsp;&nbsp;&nbsp;&nbsp;outputsize=100 ).as_pandas()  # Fetch historical price data for Microsoft msft_ts = td.time_series( &nbsp;&nbsp;&nbsp;&nbsp;symbol=\"MSFT\", &nbsp;&nbsp;&nbsp;&nbsp;interval=\"1day\", &nbsp;&nbsp;&nbsp;&nbsp;outputsize=100 ).as_pandas()  # Align data on datetime index combined = pd.concat( &nbsp;&nbsp;&nbsp;&nbsp;[tsla_ts['close'].astype(float), msft_ts['close'].astype(float)], &nbsp;&nbsp;&nbsp;&nbsp;axis=1, &nbsp;&nbsp;&nbsp;&nbsp;keys=[\"TSLA\", \"MSFT\"] ).dropna()  # Calculate correlation correlation = combined[\"TSLA\"].corr(combined[\"MSFT\"]) print(f\"Correlation of closing prices between TSLA and MSFT: {correlation:.2f}\") ```  ### Authentication  Authenticate your requests using one of these methods:  #### Query parameter method ``` GET https://api.twelvedata.com/endpoint?symbol=AAPL&apikey=your_api_key ```  #### HTTP header method (recommended) ``` Authorization: apikey your_api_key ```  ##### API key useful information <ul> <li> Demo API key (<code>apikey=demo</code>) available for demo requests</li> <li> Personal API key required for full access</li> <li> Premium endpoints and data require higher-tier plans (testable with <a href=\"https://twelvedata.com/exchanges\">trial symbols</a>)</li> </ul>  ### API endpoints   Service | Base URL | ---------|----------|  REST API | `https://api.twelvedata.com` |  WebSocket | `wss://ws.twelvedata.com` |  ### Parameter guidelines <ul> <li><b>Separator:</b> Use <code>&</code> to separate multiple parameters</li> <li><b>Case sensitivity:</b> Parameter names are case-insensitive</li>  <ul><li><code>symbol=AAPL</code> = <code>symbol=aapl</code></li></ul>  <li><b>Multiple values:</b> Separate with commas where supported</li> </ul>  ### Response handling  #### Default format All responses return JSON format by default unless otherwise specified.  #### Null values <b>Important:</b> Some response fields may contain `null` values when data is unavailable for specific metrics. This is expected behavior, not an error.  ##### Best Practices: <ul> <li>Always implement <code>null</code> value handling in your application</li> <li>Use defensive programming techniques for data processing</li> <li>Consider fallback values or error handling for critical metrics</li> </ul>  #### Error handling Structure your code to gracefully handle: <ul> <li>Network timeouts</li> <li>Rate limiting responses</li> <li>Invalid parameter errors</li> <li>Data unavailability periods</li> </ul>  ##### Best practices <ul> <li><b>Rate limits:</b> Adhere to your plan’s rate limits to avoid throttling. Check your dashboard for details.</li> <li><b>Error handling:</b> Implement retry logic for transient errors (e.g., <code>429 Too Many Requests</code>).</li> <li><b>Caching:</b> Cache responses for frequently accessed data to reduce API calls and improve performance.</li> <li><b>Secure storage:</b> Store your API key securely and never expose it in client-side code or public repositories.</li> </ul>  ## Errors  Twelve Data API employs a standardized error response format, delivering a JSON object with `code`, `message`, and `status` keys for clear and consistent error communication.  ### Codes  Below is a table of possible error codes, their HTTP status, meanings, and resolution steps:   Code | status | Meaning | Resolution |  --- | --- | --- | --- |  **400** | Bad Request | Invalid or incorrect parameter(s) provided. | Check the `message` in the response for details. Refer to the API Documenta­tion to correct the input. |  **401** | Unauthor­ized | Invalid or incorrect API key. | Verify your API key is correct. Sign up for a key <a href=\"https://twelvedata.com/account/api-keys\">here</a>. |  **403** | Forbidden | API key lacks permissions for the requested resource (upgrade required). | Upgrade your plan <a href=\"https://twelvedata.com/pricing\">here</a>. |  **404** | Not Found | Requested data could not be found. | Adjust parameters to be less strict as they may be too restrictive. |  **414** | Parameter Too Long | Input parameter array exceeds the allowed length. | Follow the `message` guidance to adjust the parameter length. |  **429** | Too Many Requests | API request limit reached for your key. | Wait briefly or upgrade your plan <a href=\"https://twelvedata.com/pricing\">here</a>. |  **500** | Internal Server Error | Server-side issue occurred; retry later. | Contact support <a href=\"https://twelvedata.com/contact\">here</a> for assistance. |  ### Example error response  Consider the following invalid request:  ``` https://api.twelvedata.com/time_series?symbol=AAPL&interval=0.99min&apikey=your_api_key ```  Due to the incorrect `interval` value, the API returns:  ```json { &nbsp;&nbsp;\"code\": 400, &nbsp;&nbsp;\"message\": \"Invalid **interval** provided: 0.99min. Supported intervals: 1min, 5min, 15min, 30min, 45min, 1h, 2h, 4h, 8h, 1day, 1week, 1month\", &nbsp;&nbsp;\"status\": \"error\" } ```  Refer to the API Documentation for valid parameter values to resolve such errors.  ## Libraries  Twelve Data provides a growing ecosystem of libraries and integrations to help you build faster and smarter in your preferred environment. Official libraries are actively maintained by the Twelve Data team, while selected community-built libraries offer additional flexibility.  A full list is available on our [GitHub profile](https://github.com/search?q=twelvedata).  ### Official SDKs <ul> <li><b>Python:</b> <a href=\"https://github.com/twelvedata/twelvedata-python\">twelvedata-python</a></li> <li><b>R:</b> <a href=\"https://github.com/twelvedata/twelvedata-r-sdk\">twelvedata-r-sdk</a></li> </ul>  ### AI integrations <ul> <li><b>Twelve Data MCP Server:</b> <a href=\"https://github.com/twelvedata/mcp\">Repository</a> — Model Context Protocol (MCP) server that provides seamless integration with AI assistants and language models, enabling direct access to Twelve Data's financial market data within conversational interfaces and AI workflows.</li> </ul>  ### Spreadsheet add-ons <ul> <li><b>Excel:</b> <a href=\"https://twelvedata.com/excel\">Excel Add-in</a></li> <li><b>Google Sheets:</b> <a href=\"https://twelvedata.com/google-sheets\">Google Sheets Add-on</a></li> </ul>  ### Community libraries  The community has developed libraries in several popular languages. You can explore more community libraries on [GitHub](https://github.com/search?q=twelvedata). <ul> <li><b>C#:</b> <a href=\"https://github.com/pseudomarkets/TwelveDataSharp\">TwelveDataSharp</a></li> <li><b>JavaScript:</b> <a href=\"https://github.com/evzaboun/twelvedata\">twelvedata</a></li> <li><b>PHP:</b> <a href=\"https://github.com/ingelby/twelvedata\">twelvedata</a></li> <li><b>Go:</b> <a href=\"https://github.com/soulgarden/twelvedata\">twelvedata</a></li> <li><b>TypeScript:</b> <a href=\"https://github.com/Clyde-Goodall/twelve-data-wrapper\">twelve-data-wrapper</a></li> </ul>  ### Other Twelve Data repositories <ul> <li><b>searchindex</b> <i>(Go)</i>: <a href=\"https://github.com/twelvedata/searchindex\">Repository</a> — In-memory search index by strings</li> <li><b>ws-tools</b> <i>(Python)</i>: <a href=\"https://github.com/twelvedata/ws-tools\">Repository</a> — Utility tools for WebSocket stream handling</li> </ul>  ### API specification <ul> <li><b>OpenAPI / Swagger:</b> Access the <a href=\"https://api.twelvedata.com/doc/swagger/openapi.json\">complete API specification</a> in OpenAPI format. You can use this file to automatically generate client libraries in your preferred programming language, explore the API interactively via Swagger tools, or integrate Twelve Data seamlessly into your AI and LLM workflows.</li> </ul>
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`get_time_series_ad`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAdParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAdParamsBuilder {
        GetTimeSeriesAdParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAdParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAdParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAdParams {
        GetTimeSeriesAdParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ad_osc`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdOscParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAdOscParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAdOscParamsBuilder {
        GetTimeSeriesAdOscParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAdOscParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdOscParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAdOscParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAdOscParams {
        GetTimeSeriesAdOscParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            fast_period: self.fast_period,
            slow_period: self.slow_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_add`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAddParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAddParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAddParamsBuilder {
        GetTimeSeriesAddParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAddParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAddParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAddParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAddParams {
        GetTimeSeriesAddParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_adx`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdxParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAdxParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAdxParamsBuilder {
        GetTimeSeriesAdxParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAdxParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdxParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAdxParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAdxParams {
        GetTimeSeriesAdxParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_adxr`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdxrParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAdxrParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAdxrParamsBuilder {
        GetTimeSeriesAdxrParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAdxrParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAdxrParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAdxrParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAdxrParams {
        GetTimeSeriesAdxrParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_apo`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesApoParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesApoParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesApoParamsBuilder {
        GetTimeSeriesApoParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesApoParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesApoParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesApoParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesApoParams {
        GetTimeSeriesApoParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_period: self.fast_period,
            slow_period: self.slow_period,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_aroon`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAroonParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAroonParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAroonParamsBuilder {
        GetTimeSeriesAroonParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAroonParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAroonParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAroonParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAroonParams {
        GetTimeSeriesAroonParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_aroon_osc`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAroonOscParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAroonOscParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAroonOscParamsBuilder {
        GetTimeSeriesAroonOscParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAroonOscParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAroonOscParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAroonOscParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAroonOscParams {
        GetTimeSeriesAroonOscParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_atr`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAtrParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAtrParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAtrParamsBuilder {
        GetTimeSeriesAtrParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAtrParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAtrParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAtrParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAtrParams {
        GetTimeSeriesAtrParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_avg`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAvgParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAvgParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAvgParamsBuilder {
        GetTimeSeriesAvgParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAvgParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAvgParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAvgParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAvgParams {
        GetTimeSeriesAvgParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_avg_price`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAvgPriceParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesAvgPriceParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesAvgPriceParamsBuilder {
        GetTimeSeriesAvgPriceParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesAvgPriceParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesAvgPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesAvgPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesAvgPriceParams {
        GetTimeSeriesAvgPriceParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_b_bands`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBBandsParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Number of standard deviations. Must be at least `1`
    pub sd: Option<f64>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesBBandsParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesBBandsParamsBuilder {
        GetTimeSeriesBBandsParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesBBandsParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBBandsParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Number of standard deviations. Must be at least `1`
    sd: Option<f64>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesBBandsParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Number of standard deviations. Must be at least `1`
    pub fn sd(mut self, sd: f64) -> Self {
        
        self.sd = Some(sd);
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesBBandsParams {
        GetTimeSeriesBBandsParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            sd: self.sd,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_beta`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBetaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesBetaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesBetaParamsBuilder {
        GetTimeSeriesBetaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesBetaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBetaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesBetaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesBetaParams {
        GetTimeSeriesBetaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_bop`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBopParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesBopParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesBopParamsBuilder {
        GetTimeSeriesBopParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesBopParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesBopParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesBopParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesBopParams {
        GetTimeSeriesBopParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_cci`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCciParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCciParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCciParamsBuilder {
        GetTimeSeriesCciParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCciParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCciParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCciParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCciParams {
        GetTimeSeriesCciParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ceil`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCeilParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCeilParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCeilParamsBuilder {
        GetTimeSeriesCeilParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCeilParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCeilParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCeilParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCeilParams {
        GetTimeSeriesCeilParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_cmo`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCmoParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCmoParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCmoParamsBuilder {
        GetTimeSeriesCmoParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCmoParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCmoParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCmoParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCmoParams {
        GetTimeSeriesCmoParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_coppock`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCoppockParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for weighted moving average. Takes values in the range from `1` to `800`
    pub wma_period: Option<i64>,
    /// Number of periods for long term rate of change. Takes values in the range from `1` to `800`
    pub long_roc_period: Option<i64>,
    /// Number of periods for short term rate of change. Takes values in the range from `1` to `800`
    pub short_roc_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCoppockParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCoppockParamsBuilder {
        GetTimeSeriesCoppockParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCoppockParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCoppockParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for weighted moving average. Takes values in the range from `1` to `800`
    wma_period: Option<i64>,
    /// Number of periods for long term rate of change. Takes values in the range from `1` to `800`
    long_roc_period: Option<i64>,
    /// Number of periods for short term rate of change. Takes values in the range from `1` to `800`
    short_roc_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCoppockParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for weighted moving average. Takes values in the range from `1` to `800`
    pub fn wma_period(mut self, wma_period: i64) -> Self {
        
        self.wma_period = Some(wma_period);
        
        self
    }
    /// Number of periods for long term rate of change. Takes values in the range from `1` to `800`
    pub fn long_roc_period(mut self, long_roc_period: i64) -> Self {
        
        self.long_roc_period = Some(long_roc_period);
        
        self
    }
    /// Number of periods for short term rate of change. Takes values in the range from `1` to `800`
    pub fn short_roc_period(mut self, short_roc_period: i64) -> Self {
        
        self.short_roc_period = Some(short_roc_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCoppockParams {
        GetTimeSeriesCoppockParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            wma_period: self.wma_period,
            long_roc_period: self.long_roc_period,
            short_roc_period: self.short_roc_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_correl`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCorrelParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCorrelParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCorrelParamsBuilder {
        GetTimeSeriesCorrelParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCorrelParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCorrelParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCorrelParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCorrelParams {
        GetTimeSeriesCorrelParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_crsi`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCrsiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for RSI used to calculate price momentum. Takes values in the range from `1` to `800`
    pub rsi_period: Option<i64>,
    /// Number of periods for RSI used to calculate up/down trend. Takes values in the range from `1` to `800`
    pub up_down_length: Option<i64>,
    /// Number of periods used to calculate PercentRank. Takes values in the range from `1` to `800`
    pub percent_rank_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesCrsiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesCrsiParamsBuilder {
        GetTimeSeriesCrsiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesCrsiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesCrsiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for RSI used to calculate price momentum. Takes values in the range from `1` to `800`
    rsi_period: Option<i64>,
    /// Number of periods for RSI used to calculate up/down trend. Takes values in the range from `1` to `800`
    up_down_length: Option<i64>,
    /// Number of periods used to calculate PercentRank. Takes values in the range from `1` to `800`
    percent_rank_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesCrsiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for RSI used to calculate price momentum. Takes values in the range from `1` to `800`
    pub fn rsi_period(mut self, rsi_period: i64) -> Self {
        
        self.rsi_period = Some(rsi_period);
        
        self
    }
    /// Number of periods for RSI used to calculate up/down trend. Takes values in the range from `1` to `800`
    pub fn up_down_length(mut self, up_down_length: i64) -> Self {
        
        self.up_down_length = Some(up_down_length);
        
        self
    }
    /// Number of periods used to calculate PercentRank. Takes values in the range from `1` to `800`
    pub fn percent_rank_period(mut self, percent_rank_period: i64) -> Self {
        
        self.percent_rank_period = Some(percent_rank_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesCrsiParams {
        GetTimeSeriesCrsiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            rsi_period: self.rsi_period,
            up_down_length: self.up_down_length,
            percent_rank_period: self.percent_rank_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_dema`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDemaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesDemaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesDemaParamsBuilder {
        GetTimeSeriesDemaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesDemaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDemaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesDemaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesDemaParams {
        GetTimeSeriesDemaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_div`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDivParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesDivParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesDivParamsBuilder {
        GetTimeSeriesDivParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesDivParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDivParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesDivParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesDivParams {
        GetTimeSeriesDivParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_dpo`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDpoParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specifies if there should be a shift to match the current price
    pub centered: Option<bool>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesDpoParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesDpoParamsBuilder {
        GetTimeSeriesDpoParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesDpoParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDpoParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specifies if there should be a shift to match the current price
    centered: Option<bool>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesDpoParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specifies if there should be a shift to match the current price
    pub fn centered(mut self, centered: bool) -> Self {
        
        self.centered = Some(centered);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesDpoParams {
        GetTimeSeriesDpoParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            centered: self.centered,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_dx`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDxParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesDxParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesDxParamsBuilder {
        GetTimeSeriesDxParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesDxParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesDxParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesDxParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesDxParams {
        GetTimeSeriesDxParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ema`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesEmaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesEmaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesEmaParamsBuilder {
        GetTimeSeriesEmaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesEmaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesEmaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesEmaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesEmaParams {
        GetTimeSeriesEmaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_exp`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesExpParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesExpParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesExpParamsBuilder {
        GetTimeSeriesExpParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesExpParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesExpParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesExpParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesExpParams {
        GetTimeSeriesExpParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_floor`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesFloorParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesFloorParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesFloorParamsBuilder {
        GetTimeSeriesFloorParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesFloorParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesFloorParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesFloorParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesFloorParams {
        GetTimeSeriesFloorParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_heikinashi_candles`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHeikinashiCandlesParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHeikinashiCandlesParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHeikinashiCandlesParamsBuilder {
        GetTimeSeriesHeikinashiCandlesParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHeikinashiCandlesParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHeikinashiCandlesParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHeikinashiCandlesParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHeikinashiCandlesParams {
        GetTimeSeriesHeikinashiCandlesParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_hlc3`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHlc3Params {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHlc3Params {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHlc3ParamsBuilder {
        GetTimeSeriesHlc3ParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHlc3Params`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHlc3ParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHlc3ParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHlc3Params {
        GetTimeSeriesHlc3Params {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_dc_period`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtDcPeriodParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtDcPeriodParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtDcPeriodParamsBuilder {
        GetTimeSeriesHtDcPeriodParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtDcPeriodParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtDcPeriodParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtDcPeriodParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtDcPeriodParams {
        GetTimeSeriesHtDcPeriodParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_dc_phase`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtDcPhaseParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtDcPhaseParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtDcPhaseParamsBuilder {
        GetTimeSeriesHtDcPhaseParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtDcPhaseParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtDcPhaseParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtDcPhaseParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtDcPhaseParams {
        GetTimeSeriesHtDcPhaseParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_phasor`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtPhasorParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtPhasorParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtPhasorParamsBuilder {
        GetTimeSeriesHtPhasorParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtPhasorParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtPhasorParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtPhasorParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtPhasorParams {
        GetTimeSeriesHtPhasorParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_sine`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtSineParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtSineParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtSineParamsBuilder {
        GetTimeSeriesHtSineParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtSineParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtSineParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtSineParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtSineParams {
        GetTimeSeriesHtSineParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_trend_mode`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtTrendModeParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtTrendModeParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtTrendModeParamsBuilder {
        GetTimeSeriesHtTrendModeParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtTrendModeParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtTrendModeParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtTrendModeParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtTrendModeParams {
        GetTimeSeriesHtTrendModeParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ht_trendline`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtTrendlineParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesHtTrendlineParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesHtTrendlineParamsBuilder {
        GetTimeSeriesHtTrendlineParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesHtTrendlineParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesHtTrendlineParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesHtTrendlineParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesHtTrendlineParams {
        GetTimeSeriesHtTrendlineParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ichimoku`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesIchimokuParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The time period used for generating the conversation line. Takes values in the range from `1` to `800`
    pub conversion_line_period: Option<i64>,
    /// The time period used for generating the base line. Takes values in the range from `1` to `800`
    pub base_line_period: Option<i64>,
    /// The time period used for generating the leading span B line. Takes values in the range from `1` to `800`
    pub leading_span_b_period: Option<i64>,
    /// The time period used for generating the lagging span line. Takes values in the range from `1` to `800`
    pub lagging_span_period: Option<i64>,
    /// Indicates whether to include ahead span period
    pub include_ahead_span_period: Option<bool>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesIchimokuParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesIchimokuParamsBuilder {
        GetTimeSeriesIchimokuParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesIchimokuParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesIchimokuParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The time period used for generating the conversation line. Takes values in the range from `1` to `800`
    conversion_line_period: Option<i64>,
    /// The time period used for generating the base line. Takes values in the range from `1` to `800`
    base_line_period: Option<i64>,
    /// The time period used for generating the leading span B line. Takes values in the range from `1` to `800`
    leading_span_b_period: Option<i64>,
    /// The time period used for generating the lagging span line. Takes values in the range from `1` to `800`
    lagging_span_period: Option<i64>,
    /// Indicates whether to include ahead span period
    include_ahead_span_period: Option<bool>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesIchimokuParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The time period used for generating the conversation line. Takes values in the range from `1` to `800`
    pub fn conversion_line_period(mut self, conversion_line_period: i64) -> Self {
        
        self.conversion_line_period = Some(conversion_line_period);
        
        self
    }
    /// The time period used for generating the base line. Takes values in the range from `1` to `800`
    pub fn base_line_period(mut self, base_line_period: i64) -> Self {
        
        self.base_line_period = Some(base_line_period);
        
        self
    }
    /// The time period used for generating the leading span B line. Takes values in the range from `1` to `800`
    pub fn leading_span_b_period(mut self, leading_span_b_period: i64) -> Self {
        
        self.leading_span_b_period = Some(leading_span_b_period);
        
        self
    }
    /// The time period used for generating the lagging span line. Takes values in the range from `1` to `800`
    pub fn lagging_span_period(mut self, lagging_span_period: i64) -> Self {
        
        self.lagging_span_period = Some(lagging_span_period);
        
        self
    }
    /// Indicates whether to include ahead span period
    pub fn include_ahead_span_period(mut self, include_ahead_span_period: bool) -> Self {
        
        self.include_ahead_span_period = Some(include_ahead_span_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesIchimokuParams {
        GetTimeSeriesIchimokuParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            conversion_line_period: self.conversion_line_period,
            base_line_period: self.base_line_period,
            leading_span_b_period: self.leading_span_b_period,
            lagging_span_period: self.lagging_span_period,
            include_ahead_span_period: self.include_ahead_span_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_kama`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKamaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesKamaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesKamaParamsBuilder {
        GetTimeSeriesKamaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesKamaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKamaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesKamaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesKamaParams {
        GetTimeSeriesKamaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_keltner`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKeltnerParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// The time period used for calculating the Average True Range. Takes values in the range from `1` to `800`
    pub atr_time_period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity
    pub multiplier: Option<i64>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesKeltnerParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesKeltnerParamsBuilder {
        GetTimeSeriesKeltnerParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesKeltnerParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKeltnerParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// The time period used for calculating the Average True Range. Takes values in the range from `1` to `800`
    atr_time_period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity
    multiplier: Option<i64>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesKeltnerParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// The time period used for calculating the Average True Range. Takes values in the range from `1` to `800`
    pub fn atr_time_period(mut self, atr_time_period: i64) -> Self {
        
        self.atr_time_period = Some(atr_time_period);
        
        self
    }
    /// The factor used to adjust the indicator's sensitivity
    pub fn multiplier(mut self, multiplier: i64) -> Self {
        
        self.multiplier = Some(multiplier);
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesKeltnerParams {
        GetTimeSeriesKeltnerParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            atr_time_period: self.atr_time_period,
            multiplier: self.multiplier,
            series_type: self.series_type,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_kst`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKstParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The time period for the first Rate of Change calculation.
    pub roc_period_1: Option<i64>,
    /// The time period for the second Rate of Change calculation.
    pub roc_period_2: Option<i64>,
    /// The time period for the third Rate of Change calculation.
    pub roc_period_3: Option<i64>,
    /// The time period for the forth Rate of Change calculation.
    pub roc_period_4: Option<i64>,
    /// The time period for the first Simple Moving Average.
    pub sma_period_1: Option<i64>,
    /// The time period for the second Simple Moving Average.
    pub sma_period_2: Option<i64>,
    /// The time period for the third Simple Moving Average.
    pub sma_period_3: Option<i64>,
    /// The time period for the forth Simple Moving Average.
    pub sma_period_4: Option<i64>,
    /// The time period used for generating the signal line.
    pub signal_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesKstParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesKstParamsBuilder {
        GetTimeSeriesKstParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesKstParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesKstParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The time period for the first Rate of Change calculation.
    roc_period_1: Option<i64>,
    /// The time period for the second Rate of Change calculation.
    roc_period_2: Option<i64>,
    /// The time period for the third Rate of Change calculation.
    roc_period_3: Option<i64>,
    /// The time period for the forth Rate of Change calculation.
    roc_period_4: Option<i64>,
    /// The time period for the first Simple Moving Average.
    sma_period_1: Option<i64>,
    /// The time period for the second Simple Moving Average.
    sma_period_2: Option<i64>,
    /// The time period for the third Simple Moving Average.
    sma_period_3: Option<i64>,
    /// The time period for the forth Simple Moving Average.
    sma_period_4: Option<i64>,
    /// The time period used for generating the signal line.
    signal_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesKstParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The time period for the first Rate of Change calculation.
    pub fn roc_period_1(mut self, roc_period_1: i64) -> Self {
        
        self.roc_period_1 = Some(roc_period_1);
        
        self
    }
    /// The time period for the second Rate of Change calculation.
    pub fn roc_period_2(mut self, roc_period_2: i64) -> Self {
        
        self.roc_period_2 = Some(roc_period_2);
        
        self
    }
    /// The time period for the third Rate of Change calculation.
    pub fn roc_period_3(mut self, roc_period_3: i64) -> Self {
        
        self.roc_period_3 = Some(roc_period_3);
        
        self
    }
    /// The time period for the forth Rate of Change calculation.
    pub fn roc_period_4(mut self, roc_period_4: i64) -> Self {
        
        self.roc_period_4 = Some(roc_period_4);
        
        self
    }
    /// The time period for the first Simple Moving Average.
    pub fn sma_period_1(mut self, sma_period_1: i64) -> Self {
        
        self.sma_period_1 = Some(sma_period_1);
        
        self
    }
    /// The time period for the second Simple Moving Average.
    pub fn sma_period_2(mut self, sma_period_2: i64) -> Self {
        
        self.sma_period_2 = Some(sma_period_2);
        
        self
    }
    /// The time period for the third Simple Moving Average.
    pub fn sma_period_3(mut self, sma_period_3: i64) -> Self {
        
        self.sma_period_3 = Some(sma_period_3);
        
        self
    }
    /// The time period for the forth Simple Moving Average.
    pub fn sma_period_4(mut self, sma_period_4: i64) -> Self {
        
        self.sma_period_4 = Some(sma_period_4);
        
        self
    }
    /// The time period used for generating the signal line.
    pub fn signal_period(mut self, signal_period: i64) -> Self {
        
        self.signal_period = Some(signal_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesKstParams {
        GetTimeSeriesKstParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            roc_period_1: self.roc_period_1,
            roc_period_2: self.roc_period_2,
            roc_period_3: self.roc_period_3,
            roc_period_4: self.roc_period_4,
            sma_period_1: self.sma_period_1,
            sma_period_2: self.sma_period_2,
            sma_period_3: self.sma_period_3,
            sma_period_4: self.sma_period_4,
            signal_period: self.signal_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_linear_reg`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLinearRegParamsBuilder {
        GetTimeSeriesLinearRegParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLinearRegParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLinearRegParams {
        GetTimeSeriesLinearRegParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_linear_reg_angle`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegAngleParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegAngleParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLinearRegAngleParamsBuilder {
        GetTimeSeriesLinearRegAngleParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLinearRegAngleParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegAngleParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegAngleParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLinearRegAngleParams {
        GetTimeSeriesLinearRegAngleParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_linear_reg_intercept`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegInterceptParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegInterceptParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLinearRegInterceptParamsBuilder {
        GetTimeSeriesLinearRegInterceptParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLinearRegInterceptParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegInterceptParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegInterceptParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLinearRegInterceptParams {
        GetTimeSeriesLinearRegInterceptParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_linear_reg_slope`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegSlopeParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegSlopeParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLinearRegSlopeParamsBuilder {
        GetTimeSeriesLinearRegSlopeParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLinearRegSlopeParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLinearRegSlopeParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLinearRegSlopeParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLinearRegSlopeParams {
        GetTimeSeriesLinearRegSlopeParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ln`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLnParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLnParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLnParamsBuilder {
        GetTimeSeriesLnParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLnParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLnParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLnParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLnParams {
        GetTimeSeriesLnParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_log10`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLog10Params {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesLog10Params {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesLog10ParamsBuilder {
        GetTimeSeriesLog10ParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesLog10Params`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesLog10ParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesLog10ParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesLog10Params {
        GetTimeSeriesLog10Params {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ma`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMaParamsBuilder {
        GetTimeSeriesMaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMaParams {
        GetTimeSeriesMaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_macd`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// The time period used for generating the signal line.
    pub signal_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMacdParamsBuilder {
        GetTimeSeriesMacdParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMacdParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// The time period used for generating the signal line.
    signal_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// The time period used for generating the signal line.
    pub fn signal_period(mut self, signal_period: i64) -> Self {
        
        self.signal_period = Some(signal_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMacdParams {
        GetTimeSeriesMacdParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_period: self.fast_period,
            slow_period: self.slow_period,
            signal_period: self.signal_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_macd_ext`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdExtParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// The type of fast moving average used in the calculation.
    pub fast_ma_type: Option<String>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// The type of slow moving average used in the calculation.
    pub slow_ma_type: Option<String>,
    /// The time period used for generating the signal line.
    pub signal_period: Option<i64>,
    /// The type of fast moving average used for generating the signal line.
    pub signal_ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdExtParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMacdExtParamsBuilder {
        GetTimeSeriesMacdExtParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMacdExtParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdExtParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// The type of fast moving average used in the calculation.
    fast_ma_type: Option<String>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// The type of slow moving average used in the calculation.
    slow_ma_type: Option<String>,
    /// The time period used for generating the signal line.
    signal_period: Option<i64>,
    /// The type of fast moving average used for generating the signal line.
    signal_ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdExtParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// The type of fast moving average used in the calculation.
    pub fn fast_ma_type(mut self, fast_ma_type: impl Into<String>) -> Self {
        self.fast_ma_type = Some(fast_ma_type.into());
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// The type of slow moving average used in the calculation.
    pub fn slow_ma_type(mut self, slow_ma_type: impl Into<String>) -> Self {
        self.slow_ma_type = Some(slow_ma_type.into());
        
        self
    }
    /// The time period used for generating the signal line.
    pub fn signal_period(mut self, signal_period: i64) -> Self {
        
        self.signal_period = Some(signal_period);
        
        self
    }
    /// The type of fast moving average used for generating the signal line.
    pub fn signal_ma_type(mut self, signal_ma_type: impl Into<String>) -> Self {
        self.signal_ma_type = Some(signal_ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMacdExtParams {
        GetTimeSeriesMacdExtParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_period: self.fast_period,
            fast_ma_type: self.fast_ma_type,
            slow_period: self.slow_period,
            slow_ma_type: self.slow_ma_type,
            signal_period: self.signal_period,
            signal_ma_type: self.signal_ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_macd_slope`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdSlopeParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// The time period used for generating the signal line.
    pub signal_period: Option<i64>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdSlopeParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMacdSlopeParamsBuilder {
        GetTimeSeriesMacdSlopeParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMacdSlopeParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMacdSlopeParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// The time period used for generating the signal line.
    signal_period: Option<i64>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMacdSlopeParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// The time period used for generating the signal line.
    pub fn signal_period(mut self, signal_period: i64) -> Self {
        
        self.signal_period = Some(signal_period);
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMacdSlopeParams {
        GetTimeSeriesMacdSlopeParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_period: self.fast_period,
            slow_period: self.slow_period,
            signal_period: self.signal_period,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mama`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMamaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// The limit for the fast moving average.
    pub fast_limit: Option<f64>,
    /// The limit for the slow moving average.
    pub slow_limit: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMamaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMamaParamsBuilder {
        GetTimeSeriesMamaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMamaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMamaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// The limit for the fast moving average.
    fast_limit: Option<f64>,
    /// The limit for the slow moving average.
    slow_limit: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMamaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// The limit for the fast moving average.
    pub fn fast_limit(mut self, fast_limit: f64) -> Self {
        
        self.fast_limit = Some(fast_limit);
        
        self
    }
    /// The limit for the slow moving average.
    pub fn slow_limit(mut self, slow_limit: f64) -> Self {
        
        self.slow_limit = Some(slow_limit);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMamaParams {
        GetTimeSeriesMamaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_limit: self.fast_limit,
            slow_limit: self.slow_limit,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_max`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaxParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMaxParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMaxParamsBuilder {
        GetTimeSeriesMaxParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMaxParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaxParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMaxParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMaxParams {
        GetTimeSeriesMaxParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_max_index`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaxIndexParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMaxIndexParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMaxIndexParamsBuilder {
        GetTimeSeriesMaxIndexParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMaxIndexParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMaxIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMaxIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMaxIndexParams {
        GetTimeSeriesMaxIndexParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mc_ginley_dynamic`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMcGinleyDynamicParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMcGinleyDynamicParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMcGinleyDynamicParamsBuilder {
        GetTimeSeriesMcGinleyDynamicParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMcGinleyDynamicParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMcGinleyDynamicParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMcGinleyDynamicParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMcGinleyDynamicParams {
        GetTimeSeriesMcGinleyDynamicParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_med_price`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMedPriceParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMedPriceParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMedPriceParamsBuilder {
        GetTimeSeriesMedPriceParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMedPriceParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMedPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMedPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMedPriceParams {
        GetTimeSeriesMedPriceParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mfi`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMfiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMfiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMfiParamsBuilder {
        GetTimeSeriesMfiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMfiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMfiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMfiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMfiParams {
        GetTimeSeriesMfiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mid_point`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMidPointParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMidPointParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMidPointParamsBuilder {
        GetTimeSeriesMidPointParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMidPointParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMidPointParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMidPointParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMidPointParams {
        GetTimeSeriesMidPointParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mid_price`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMidPriceParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMidPriceParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMidPriceParamsBuilder {
        GetTimeSeriesMidPriceParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMidPriceParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMidPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMidPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMidPriceParams {
        GetTimeSeriesMidPriceParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_min`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinParamsBuilder {
        GetTimeSeriesMinParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinParams {
        GetTimeSeriesMinParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_min_index`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinIndexParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinIndexParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinIndexParamsBuilder {
        GetTimeSeriesMinIndexParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinIndexParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinIndexParams {
        GetTimeSeriesMinIndexParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_min_max`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinMaxParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinMaxParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinMaxParamsBuilder {
        GetTimeSeriesMinMaxParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinMaxParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinMaxParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinMaxParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinMaxParams {
        GetTimeSeriesMinMaxParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_min_max_index`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinMaxIndexParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinMaxIndexParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinMaxIndexParamsBuilder {
        GetTimeSeriesMinMaxIndexParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinMaxIndexParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinMaxIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinMaxIndexParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinMaxIndexParams {
        GetTimeSeriesMinMaxIndexParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_minus_di`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinusDiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinusDiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinusDiParamsBuilder {
        GetTimeSeriesMinusDiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinusDiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinusDiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinusDiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinusDiParams {
        GetTimeSeriesMinusDiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_minus_dm`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinusDmParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMinusDmParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMinusDmParamsBuilder {
        GetTimeSeriesMinusDmParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMinusDmParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMinusDmParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMinusDmParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMinusDmParams {
        GetTimeSeriesMinusDmParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mom`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMomParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMomParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMomParamsBuilder {
        GetTimeSeriesMomParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMomParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMomParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMomParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMomParams {
        GetTimeSeriesMomParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_mult`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMultParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesMultParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesMultParamsBuilder {
        GetTimeSeriesMultParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesMultParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesMultParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesMultParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesMultParams {
        GetTimeSeriesMultParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_natr`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesNatrParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesNatrParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesNatrParamsBuilder {
        GetTimeSeriesNatrParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesNatrParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesNatrParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesNatrParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesNatrParams {
        GetTimeSeriesNatrParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_obv`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesObvParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesObvParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesObvParamsBuilder {
        GetTimeSeriesObvParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesObvParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesObvParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesObvParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesObvParams {
        GetTimeSeriesObvParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_percent_b`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPercentBParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// The standard deviation applied in the calculation.  Must be at least `1`
    pub sd: Option<f64>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesPercentBParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesPercentBParamsBuilder {
        GetTimeSeriesPercentBParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesPercentBParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPercentBParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// The standard deviation applied in the calculation.  Must be at least `1`
    sd: Option<f64>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesPercentBParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// The standard deviation applied in the calculation.  Must be at least `1`
    pub fn sd(mut self, sd: f64) -> Self {
        
        self.sd = Some(sd);
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesPercentBParams {
        GetTimeSeriesPercentBParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            sd: self.sd,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_pivot_points_hl`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPivotPointsHlParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesPivotPointsHlParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesPivotPointsHlParamsBuilder {
        GetTimeSeriesPivotPointsHlParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesPivotPointsHlParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPivotPointsHlParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesPivotPointsHlParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesPivotPointsHlParams {
        GetTimeSeriesPivotPointsHlParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_plus_di`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPlusDiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesPlusDiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesPlusDiParamsBuilder {
        GetTimeSeriesPlusDiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesPlusDiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPlusDiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesPlusDiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesPlusDiParams {
        GetTimeSeriesPlusDiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_plus_dm`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPlusDmParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesPlusDmParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesPlusDmParamsBuilder {
        GetTimeSeriesPlusDmParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesPlusDmParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPlusDmParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesPlusDmParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesPlusDmParams {
        GetTimeSeriesPlusDmParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ppo`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPpoParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub slow_period: Option<i64>,
    /// The type of moving average used
    pub ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesPpoParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesPpoParamsBuilder {
        GetTimeSeriesPpoParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesPpoParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesPpoParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    fast_period: Option<i64>,
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    slow_period: Option<i64>,
    /// The type of moving average used
    ma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesPpoParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods for fast moving average. Takes values in the range from `1` to `800`
    pub fn fast_period(mut self, fast_period: i64) -> Self {
        
        self.fast_period = Some(fast_period);
        
        self
    }
    /// Number of periods for slow moving average. Takes values in the range from `1` to `800`
    pub fn slow_period(mut self, slow_period: i64) -> Self {
        
        self.slow_period = Some(slow_period);
        
        self
    }
    /// The type of moving average used
    pub fn ma_type(mut self, ma_type: impl Into<String>) -> Self {
        self.ma_type = Some(ma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesPpoParams {
        GetTimeSeriesPpoParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            fast_period: self.fast_period,
            slow_period: self.slow_period,
            ma_type: self.ma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_roc`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRocParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRocParamsBuilder {
        GetTimeSeriesRocParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRocParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRocParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRocParams {
        GetTimeSeriesRocParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_rocp`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocpParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRocpParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRocpParamsBuilder {
        GetTimeSeriesRocpParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRocpParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocpParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRocpParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRocpParams {
        GetTimeSeriesRocpParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_rocr`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocrParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRocrParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRocrParamsBuilder {
        GetTimeSeriesRocrParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRocrParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocrParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRocrParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRocrParams {
        GetTimeSeriesRocrParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_rocr100`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocr100Params {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRocr100Params {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRocr100ParamsBuilder {
        GetTimeSeriesRocr100ParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRocr100Params`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRocr100ParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRocr100ParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRocr100Params {
        GetTimeSeriesRocr100Params {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_rsi`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRsiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRsiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRsiParamsBuilder {
        GetTimeSeriesRsiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRsiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRsiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRsiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRsiParams {
        GetTimeSeriesRsiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_rvol`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRvolParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesRvolParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesRvolParamsBuilder {
        GetTimeSeriesRvolParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesRvolParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesRvolParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesRvolParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesRvolParams {
        GetTimeSeriesRvolParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sar`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSarParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The rate of change in the indicator's values.
    pub acceleration: Option<f64>,
    /// The maximum value considered for the indicator calculation.
    pub maximum: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSarParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSarParamsBuilder {
        GetTimeSeriesSarParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSarParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSarParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The rate of change in the indicator's values.
    acceleration: Option<f64>,
    /// The maximum value considered for the indicator calculation.
    maximum: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSarParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The rate of change in the indicator's values.
    pub fn acceleration(mut self, acceleration: f64) -> Self {
        
        self.acceleration = Some(acceleration);
        
        self
    }
    /// The maximum value considered for the indicator calculation.
    pub fn maximum(mut self, maximum: f64) -> Self {
        
        self.maximum = Some(maximum);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSarParams {
        GetTimeSeriesSarParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            acceleration: self.acceleration,
            maximum: self.maximum,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sar_ext`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSarExtParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The initial value for the indicator calculation.
    pub start_value: Option<f64>,
    /// The adjustment applied when the indicator's direction changes.
    pub offset_on_reverse: Option<f64>,
    /// The maximum acceleration value for long positions.
    pub acceleration_limit_long: Option<f64>,
    /// The acceleration value for long positions.
    pub acceleration_long: Option<f64>,
    /// The highest allowed acceleration for long positions.
    pub acceleration_max_long: Option<f64>,
    /// The maximum acceleration value for short positions.
    pub acceleration_limit_short: Option<f64>,
    /// The acceleration value for short positions.
    pub acceleration_short: Option<f64>,
    /// The highest allowed acceleration for short positions.
    pub acceleration_max_short: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSarExtParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSarExtParamsBuilder {
        GetTimeSeriesSarExtParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSarExtParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSarExtParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The initial value for the indicator calculation.
    start_value: Option<f64>,
    /// The adjustment applied when the indicator's direction changes.
    offset_on_reverse: Option<f64>,
    /// The maximum acceleration value for long positions.
    acceleration_limit_long: Option<f64>,
    /// The acceleration value for long positions.
    acceleration_long: Option<f64>,
    /// The highest allowed acceleration for long positions.
    acceleration_max_long: Option<f64>,
    /// The maximum acceleration value for short positions.
    acceleration_limit_short: Option<f64>,
    /// The acceleration value for short positions.
    acceleration_short: Option<f64>,
    /// The highest allowed acceleration for short positions.
    acceleration_max_short: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSarExtParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The initial value for the indicator calculation.
    pub fn start_value(mut self, start_value: f64) -> Self {
        
        self.start_value = Some(start_value);
        
        self
    }
    /// The adjustment applied when the indicator's direction changes.
    pub fn offset_on_reverse(mut self, offset_on_reverse: f64) -> Self {
        
        self.offset_on_reverse = Some(offset_on_reverse);
        
        self
    }
    /// The maximum acceleration value for long positions.
    pub fn acceleration_limit_long(mut self, acceleration_limit_long: f64) -> Self {
        
        self.acceleration_limit_long = Some(acceleration_limit_long);
        
        self
    }
    /// The acceleration value for long positions.
    pub fn acceleration_long(mut self, acceleration_long: f64) -> Self {
        
        self.acceleration_long = Some(acceleration_long);
        
        self
    }
    /// The highest allowed acceleration for long positions.
    pub fn acceleration_max_long(mut self, acceleration_max_long: f64) -> Self {
        
        self.acceleration_max_long = Some(acceleration_max_long);
        
        self
    }
    /// The maximum acceleration value for short positions.
    pub fn acceleration_limit_short(mut self, acceleration_limit_short: f64) -> Self {
        
        self.acceleration_limit_short = Some(acceleration_limit_short);
        
        self
    }
    /// The acceleration value for short positions.
    pub fn acceleration_short(mut self, acceleration_short: f64) -> Self {
        
        self.acceleration_short = Some(acceleration_short);
        
        self
    }
    /// The highest allowed acceleration for short positions.
    pub fn acceleration_max_short(mut self, acceleration_max_short: f64) -> Self {
        
        self.acceleration_max_short = Some(acceleration_max_short);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSarExtParams {
        GetTimeSeriesSarExtParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            start_value: self.start_value,
            offset_on_reverse: self.offset_on_reverse,
            acceleration_limit_long: self.acceleration_limit_long,
            acceleration_long: self.acceleration_long,
            acceleration_max_long: self.acceleration_max_long,
            acceleration_limit_short: self.acceleration_limit_short,
            acceleration_short: self.acceleration_short,
            acceleration_max_short: self.acceleration_max_short,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sma`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSmaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSmaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSmaParamsBuilder {
        GetTimeSeriesSmaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSmaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSmaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSmaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSmaParams {
        GetTimeSeriesSmaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sqrt`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSqrtParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSqrtParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSqrtParamsBuilder {
        GetTimeSeriesSqrtParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSqrtParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSqrtParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSqrtParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSqrtParams {
        GetTimeSeriesSqrtParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_std_dev`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStdDevParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// The standard deviation applied in the calculation.
    pub sd: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesStdDevParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesStdDevParamsBuilder {
        GetTimeSeriesStdDevParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesStdDevParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStdDevParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// The standard deviation applied in the calculation.
    sd: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesStdDevParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// The standard deviation applied in the calculation.
    pub fn sd(mut self, sd: f64) -> Self {
        
        self.sd = Some(sd);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesStdDevParams {
        GetTimeSeriesStdDevParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            sd: self.sd,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_stoch`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fast_k_period: Option<i64>,
    /// The time period for the slow %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub slow_k_period: Option<i64>,
    /// The time period for the slow %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub slow_d_period: Option<i64>,
    /// The type of slow %K Moving Average used. Default is SMA.
    pub slow_kma_type: Option<String>,
    /// The type of slow Displaced Moving Average used. Default is SMA.
    pub slow_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesStochParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesStochParamsBuilder {
        GetTimeSeriesStochParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesStochParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    fast_k_period: Option<i64>,
    /// The time period for the slow %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    slow_k_period: Option<i64>,
    /// The time period for the slow %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    slow_d_period: Option<i64>,
    /// The type of slow %K Moving Average used. Default is SMA.
    slow_kma_type: Option<String>,
    /// The type of slow Displaced Moving Average used. Default is SMA.
    slow_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesStochParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fn fast_k_period(mut self, fast_k_period: i64) -> Self {
        
        self.fast_k_period = Some(fast_k_period);
        
        self
    }
    /// The time period for the slow %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fn slow_k_period(mut self, slow_k_period: i64) -> Self {
        
        self.slow_k_period = Some(slow_k_period);
        
        self
    }
    /// The time period for the slow %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fn slow_d_period(mut self, slow_d_period: i64) -> Self {
        
        self.slow_d_period = Some(slow_d_period);
        
        self
    }
    /// The type of slow %K Moving Average used. Default is SMA.
    pub fn slow_kma_type(mut self, slow_kma_type: impl Into<String>) -> Self {
        self.slow_kma_type = Some(slow_kma_type.into());
        
        self
    }
    /// The type of slow Displaced Moving Average used. Default is SMA.
    pub fn slow_dma_type(mut self, slow_dma_type: impl Into<String>) -> Self {
        self.slow_dma_type = Some(slow_dma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesStochParams {
        GetTimeSeriesStochParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            fast_k_period: self.fast_k_period,
            slow_k_period: self.slow_k_period,
            slow_d_period: self.slow_d_period,
            slow_kma_type: self.slow_kma_type,
            slow_dma_type: self.slow_dma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_stoch_f`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochFParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fast_k_period: Option<i64>,
    /// The time period for the fast %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fast_d_period: Option<i64>,
    /// The type of fast Displaced Moving Average used.
    pub fast_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesStochFParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesStochFParamsBuilder {
        GetTimeSeriesStochFParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesStochFParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochFParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    fast_k_period: Option<i64>,
    /// The time period for the fast %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    fast_d_period: Option<i64>,
    /// The type of fast Displaced Moving Average used.
    fast_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesStochFParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The time period for the fast %K line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fn fast_k_period(mut self, fast_k_period: i64) -> Self {
        
        self.fast_k_period = Some(fast_k_period);
        
        self
    }
    /// The time period for the fast %D line in the Stochastic Oscillator. Takes values in the range from `1` to `800`
    pub fn fast_d_period(mut self, fast_d_period: i64) -> Self {
        
        self.fast_d_period = Some(fast_d_period);
        
        self
    }
    /// The type of fast Displaced Moving Average used.
    pub fn fast_dma_type(mut self, fast_dma_type: impl Into<String>) -> Self {
        self.fast_dma_type = Some(fast_dma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesStochFParams {
        GetTimeSeriesStochFParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            fast_k_period: self.fast_k_period,
            fast_d_period: self.fast_d_period,
            fast_dma_type: self.fast_dma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_stoch_rsi`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochRsiParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specifies the price data type: open, high, low, or close.
    pub series_type: Option<String>,
    /// Length of period for calculating the RSI component. Takes values in the range from `1` to `800`
    pub rsi_length: Option<i64>,
    /// Period length for computing the stochastic oscillator of the RSI. Takes values in the range from `1` to `800`
    pub stoch_length: Option<i64>,
    /// Period for smoothing the %K line. Takes values in the range from `1` to `800`
    pub k_period: Option<i64>,
    pub slow_kma_type: Option<String>,
    /// Period for smoothing the %D line, which is a moving average of %K. Takes values in the range from `1` to `800`
    pub d_period: Option<i64>,
    pub slow_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesStochRsiParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesStochRsiParamsBuilder {
        GetTimeSeriesStochRsiParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesStochRsiParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesStochRsiParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specifies the price data type: open, high, low, or close.
    series_type: Option<String>,
    /// Length of period for calculating the RSI component. Takes values in the range from `1` to `800`
    rsi_length: Option<i64>,
    /// Period length for computing the stochastic oscillator of the RSI. Takes values in the range from `1` to `800`
    stoch_length: Option<i64>,
    /// Period for smoothing the %K line. Takes values in the range from `1` to `800`
    k_period: Option<i64>,
    slow_kma_type: Option<String>,
    /// Period for smoothing the %D line, which is a moving average of %K. Takes values in the range from `1` to `800`
    d_period: Option<i64>,
    slow_dma_type: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesStochRsiParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specifies the price data type: open, high, low, or close.
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Length of period for calculating the RSI component. Takes values in the range from `1` to `800`
    pub fn rsi_length(mut self, rsi_length: i64) -> Self {
        
        self.rsi_length = Some(rsi_length);
        
        self
    }
    /// Period length for computing the stochastic oscillator of the RSI. Takes values in the range from `1` to `800`
    pub fn stoch_length(mut self, stoch_length: i64) -> Self {
        
        self.stoch_length = Some(stoch_length);
        
        self
    }
    /// Period for smoothing the %K line. Takes values in the range from `1` to `800`
    pub fn k_period(mut self, k_period: i64) -> Self {
        
        self.k_period = Some(k_period);
        
        self
    }
    pub fn slow_kma_type(mut self, slow_kma_type: impl Into<String>) -> Self {
        self.slow_kma_type = Some(slow_kma_type.into());
        
        self
    }
    /// Period for smoothing the %D line, which is a moving average of %K. Takes values in the range from `1` to `800`
    pub fn d_period(mut self, d_period: i64) -> Self {
        
        self.d_period = Some(d_period);
        
        self
    }
    pub fn slow_dma_type(mut self, slow_dma_type: impl Into<String>) -> Self {
        self.slow_dma_type = Some(slow_dma_type.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesStochRsiParams {
        GetTimeSeriesStochRsiParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            rsi_length: self.rsi_length,
            stoch_length: self.stoch_length,
            k_period: self.k_period,
            slow_kma_type: self.slow_kma_type,
            d_period: self.d_period,
            slow_dma_type: self.slow_dma_type,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sub`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSubParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    pub series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    pub series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSubParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSubParamsBuilder {
        GetTimeSeriesSubParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSubParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSubParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type used as the first part of technical indicator
    series_type_1: Option<String>,
    /// Price type used as the second part of technical indicator
    series_type_2: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSubParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type used as the first part of technical indicator
    pub fn series_type_1(mut self, series_type_1: impl Into<String>) -> Self {
        self.series_type_1 = Some(series_type_1.into());
        
        self
    }
    /// Price type used as the second part of technical indicator
    pub fn series_type_2(mut self, series_type_2: impl Into<String>) -> Self {
        self.series_type_2 = Some(series_type_2.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSubParams {
        GetTimeSeriesSubParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type_1: self.series_type_1,
            series_type_2: self.series_type_2,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_sum`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSumParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSumParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSumParamsBuilder {
        GetTimeSeriesSumParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSumParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSumParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSumParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSumParams {
        GetTimeSeriesSumParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_super_trend`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSuperTrendParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity.
    pub multiplier: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSuperTrendParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSuperTrendParamsBuilder {
        GetTimeSeriesSuperTrendParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSuperTrendParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSuperTrendParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity.
    multiplier: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSuperTrendParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub fn period(mut self, period: i64) -> Self {
        
        self.period = Some(period);
        
        self
    }
    /// The factor used to adjust the indicator's sensitivity.
    pub fn multiplier(mut self, multiplier: i64) -> Self {
        
        self.multiplier = Some(multiplier);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSuperTrendParams {
        GetTimeSeriesSuperTrendParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            period: self.period,
            multiplier: self.multiplier,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_super_trend_heikin_ashi_candles`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSuperTrendHeikinAshiCandlesParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity.
    pub multiplier: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesSuperTrendHeikinAshiCandlesParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesSuperTrendHeikinAshiCandlesParamsBuilder {
        GetTimeSeriesSuperTrendHeikinAshiCandlesParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesSuperTrendHeikinAshiCandlesParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesSuperTrendHeikinAshiCandlesParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    period: Option<i64>,
    /// The factor used to adjust the indicator's sensitivity.
    multiplier: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesSuperTrendHeikinAshiCandlesParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub fn period(mut self, period: i64) -> Self {
        
        self.period = Some(period);
        
        self
    }
    /// The factor used to adjust the indicator's sensitivity.
    pub fn multiplier(mut self, multiplier: i64) -> Self {
        
        self.multiplier = Some(multiplier);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesSuperTrendHeikinAshiCandlesParams {
        GetTimeSeriesSuperTrendHeikinAshiCandlesParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            period: self.period,
            multiplier: self.multiplier,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_t3ma`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesT3maParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// The factor used to adjust the indicator's volatility. Takes values in the range from `0` to `1`
    pub v_factor: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesT3maParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesT3maParamsBuilder {
        GetTimeSeriesT3maParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesT3maParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesT3maParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// The factor used to adjust the indicator's volatility. Takes values in the range from `0` to `1`
    v_factor: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesT3maParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// The factor used to adjust the indicator's volatility. Takes values in the range from `0` to `1`
    pub fn v_factor(mut self, v_factor: f64) -> Self {
        
        self.v_factor = Some(v_factor);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesT3maParams {
        GetTimeSeriesT3maParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            v_factor: self.v_factor,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_t_range`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTRangeParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesTRangeParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesTRangeParamsBuilder {
        GetTimeSeriesTRangeParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesTRangeParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTRangeParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesTRangeParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesTRangeParams {
        GetTimeSeriesTRangeParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_tema`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTemaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// The time period used for calculation in the indicator. Default is 9.
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesTemaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesTemaParamsBuilder {
        GetTimeSeriesTemaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesTemaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTemaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// The time period used for calculation in the indicator. Default is 9.
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesTemaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// The time period used for calculation in the indicator. Default is 9.
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesTemaParams {
        GetTimeSeriesTemaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_trima`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTrimaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesTrimaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesTrimaParamsBuilder {
        GetTimeSeriesTrimaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesTrimaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTrimaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesTrimaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesTrimaParams {
        GetTimeSeriesTrimaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_tsf`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTsfParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesTsfParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesTsfParamsBuilder {
        GetTimeSeriesTsfParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesTsfParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTsfParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesTsfParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesTsfParams {
        GetTimeSeriesTsfParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_typ_price`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTypPriceParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesTypPriceParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesTypPriceParamsBuilder {
        GetTimeSeriesTypPriceParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesTypPriceParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesTypPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesTypPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesTypPriceParams {
        GetTimeSeriesTypPriceParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_ult_osc`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesUltOscParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The first time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub time_period_1: Option<i64>,
    /// The second time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub time_period_2: Option<i64>,
    /// The third time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub time_period_3: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesUltOscParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesUltOscParamsBuilder {
        GetTimeSeriesUltOscParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesUltOscParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesUltOscParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The first time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    time_period_1: Option<i64>,
    /// The second time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    time_period_2: Option<i64>,
    /// The third time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    time_period_3: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesUltOscParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The first time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub fn time_period_1(mut self, time_period_1: i64) -> Self {
        
        self.time_period_1 = Some(time_period_1);
        
        self
    }
    /// The second time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub fn time_period_2(mut self, time_period_2: i64) -> Self {
        
        self.time_period_2 = Some(time_period_2);
        
        self
    }
    /// The third time period used for calculation in the indicator. Takes values in the range from `1` to `800`
    pub fn time_period_3(mut self, time_period_3: i64) -> Self {
        
        self.time_period_3 = Some(time_period_3);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesUltOscParams {
        GetTimeSeriesUltOscParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period_1: self.time_period_1,
            time_period_2: self.time_period_2,
            time_period_3: self.time_period_3,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_var`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesVarParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesVarParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesVarParamsBuilder {
        GetTimeSeriesVarParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesVarParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesVarParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesVarParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesVarParams {
        GetTimeSeriesVarParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_vwap`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesVwapParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// The time period for the standard deviation calculation. Must be greater than `0`. Recommended value is `9`. This parameter is only used together with `sd`.
    pub sd_time_period: Option<i64>,
    /// The standard deviation applied in the calculation. Must be greater than `0`. Recommended value is `2`. This parameter is only used together with `sd_time_period`.
    pub sd: Option<f64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesVwapParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesVwapParamsBuilder {
        GetTimeSeriesVwapParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesVwapParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesVwapParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// The time period for the standard deviation calculation. Must be greater than `0`. Recommended value is `9`. This parameter is only used together with `sd`.
    sd_time_period: Option<i64>,
    /// The standard deviation applied in the calculation. Must be greater than `0`. Recommended value is `2`. This parameter is only used together with `sd_time_period`.
    sd: Option<f64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesVwapParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// The time period for the standard deviation calculation. Must be greater than `0`. Recommended value is `9`. This parameter is only used together with `sd`.
    pub fn sd_time_period(mut self, sd_time_period: i64) -> Self {
        
        self.sd_time_period = Some(sd_time_period);
        
        self
    }
    /// The standard deviation applied in the calculation. Must be greater than `0`. Recommended value is `2`. This parameter is only used together with `sd_time_period`.
    pub fn sd(mut self, sd: f64) -> Self {
        
        self.sd = Some(sd);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesVwapParams {
        GetTimeSeriesVwapParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            sd_time_period: self.sd_time_period,
            sd: self.sd,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_wcl_price`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWclPriceParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesWclPriceParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesWclPriceParamsBuilder {
        GetTimeSeriesWclPriceParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesWclPriceParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWclPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesWclPriceParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesWclPriceParams {
        GetTimeSeriesWclPriceParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_will_r`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWillRParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesWillRParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesWillRParamsBuilder {
        GetTimeSeriesWillRParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesWillRParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWillRParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesWillRParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesWillRParams {
        GetTimeSeriesWillRParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}

/// struct for passing parameters to the method [`get_time_series_wma`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWmaParams {
    /// Interval between two consecutive points in time series
    pub interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    pub isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    pub figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub outputsize: Option<i64>,
    /// Exchange where instrument is traded
    pub exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub country: Option<String>,
    /// The asset class to which the instrument belongs
    pub r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    pub end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub date: Option<String>,
    /// Sorting order of the output
    pub order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub prepost: Option<bool>,
    /// The format of the response data
    pub format: Option<String>,
    /// The separator used in the CSV response data
    pub delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub previous_close: Option<bool>,
    /// Adjusting mode for prices
    pub adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    pub series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    pub include_ohlc: Option<bool>
}

impl GetTimeSeriesWmaParams {
    /// Create a new builder for this parameter struct
    pub fn builder() -> GetTimeSeriesWmaParamsBuilder {
        GetTimeSeriesWmaParamsBuilder::default()
    }
}

/// Builder for [`GetTimeSeriesWmaParams`]
#[derive(Clone, Debug, Default)]
pub struct GetTimeSeriesWmaParamsBuilder {
    /// Interval between two consecutive points in time series
    interval: String,
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    symbol: Option<String>,
    /// Filter by international securities identification number (ISIN)
    isin: Option<String>,
    /// The FIGI of an instrument for which data is requested
    figi: Option<String>,
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    cusip: Option<String>,
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    outputsize: Option<i64>,
    /// Exchange where instrument is traded
    exchange: Option<String>,
    /// Market Identifier Code (MIC) under ISO 10383 standard
    mic_code: Option<String>,
    /// The country where the instrument is traded, e.g., `United States` or `US`
    country: Option<String>,
    /// The asset class to which the instrument belongs
    r#type: Option<String>,
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    timezone: Option<String>,
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    start_date: Option<String>,
    /// The ending date and time for data selection, see `start_date` description for details.
    end_date: Option<String>,
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    date: Option<String>,
    /// Sorting order of the output
    order: Option<String>,
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    prepost: Option<bool>,
    /// The format of the response data
    format: Option<String>,
    /// The separator used in the CSV response data
    delimiter: Option<String>,
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    dp: Option<i64>,
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    previous_close: Option<bool>,
    /// Adjusting mode for prices
    adjust: Option<String>,
    /// Price type on which technical indicator is calculated
    series_type: Option<String>,
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    time_period: Option<i64>,
    /// Specify if OHLC values should be added in the output
    include_ohlc: Option<bool>
}

impl GetTimeSeriesWmaParamsBuilder {
    /// Interval between two consecutive points in time series
    pub fn interval(mut self, interval: impl Into<String>) -> Self {
        self.interval = interval.into();
        
        self
    }
    /// Symbol ticker of the instrument. E.g. `AAPL`, `EUR/USD`, `ETH/BTC`, ...
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = Some(symbol.into());
        
        self
    }
    /// Filter by international securities identification number (ISIN)
    pub fn isin(mut self, isin: impl Into<String>) -> Self {
        self.isin = Some(isin.into());
        
        self
    }
    /// The FIGI of an instrument for which data is requested
    pub fn figi(mut self, figi: impl Into<String>) -> Self {
        self.figi = Some(figi.into());
        
        self
    }
    /// The CUSIP of an instrument for which data is requested. CUSIP access is activating in the <a href=\"https://twelvedata.com/account/add-ons\">Add-ons</a> section
    pub fn cusip(mut self, cusip: impl Into<String>) -> Self {
        self.cusip = Some(cusip.into());
        
        self
    }
    /// Number of data points to retrieve. Supports values in the range from `1` to `5000`. Default `30` when no date parameters are set, otherwise set to maximum
    pub fn outputsize(mut self, outputsize: i64) -> Self {
        
        self.outputsize = Some(outputsize);
        
        self
    }
    /// Exchange where instrument is traded
    pub fn exchange(mut self, exchange: impl Into<String>) -> Self {
        self.exchange = Some(exchange.into());
        
        self
    }
    /// Market Identifier Code (MIC) under ISO 10383 standard
    pub fn mic_code(mut self, mic_code: impl Into<String>) -> Self {
        self.mic_code = Some(mic_code.into());
        
        self
    }
    /// The country where the instrument is traded, e.g., `United States` or `US`
    pub fn country(mut self, country: impl Into<String>) -> Self {
        self.country = Some(country.into());
        
        self
    }
    /// The asset class to which the instrument belongs
    pub fn r#type(mut self, r#type: impl Into<String>) -> Self {
        self.r#type = Some(r#type.into());
        
        self
    }
    /// Timezone at which output datetime will be displayed. Supports: <ul> <li>1. <code>Exchange</code> for local exchange time</li> <li>2. <code>UTC</code> for datetime at universal UTC standard</li> <li>3. Timezone name according to the IANA Time Zone Database. E.g. <code>America/New_York</code>, <code>Asia/Singapore</code>. Full list of timezones can be found <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"blank\">here</a></li> </ul> <i>Take note that the IANA Timezone name is case-sensitive</i>
    pub fn timezone(mut self, timezone: impl Into<String>) -> Self {
        self.timezone = Some(timezone.into());
        
        self
    }
    /// Can be used separately and together with `end_date`. Format `2006-01-02` or `2006-01-02T15:04:05`  Default location: <ul> <li>Forex and Cryptocurrencies - <code>UTC</code></li> <li>Stocks - where exchange is located (e.g. for AAPL it will be <code>America/New_York</code>)</li> </ul> Both parameters take into account if <code>timezone</code> parameter is provided.<br/> If <code>timezone</code> is given then, <code>start_date</code> and <code>end_date</code> will be used in the specified location  Examples: <ul> <li>1. <code>&symbol=AAPL&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 New York time up to current date</li> <li>2. <code>&symbol=EUR/USD&timezone=Asia/Singapore&start_date=2019-08-09T15:50:00&…</code><br/> Returns all records starting from 2019-08-09T15:50:00 Singapore time up to current date</li> <li>3. <code>&symbol=ETH/BTC&timezone=Europe/Zurich&start_date=2019-08-09T15:50:00&end_date=2019-08-09T15:55:00&...</code><br/> Returns all records starting from 2019-08-09T15:50:00 Zurich time up to 2019-08-09T15:55:00</li> </ul>
    pub fn start_date(mut self, start_date: impl Into<String>) -> Self {
        self.start_date = Some(start_date.into());
        
        self
    }
    /// The ending date and time for data selection, see `start_date` description for details.
    pub fn end_date(mut self, end_date: impl Into<String>) -> Self {
        self.end_date = Some(end_date.into());
        
        self
    }
    /// Specifies the exact date to get the data for. Could be the exact date, e.g. `2021-10-27`, or in human language `today` or `yesterday`
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = Some(date.into());
        
        self
    }
    /// Sorting order of the output
    pub fn order(mut self, order: impl Into<String>) -> Self {
        self.order = Some(order.into());
        
        self
    }
    /// Returns quotes that include pre-market and post-market data. Only for `Pro` and above plans. Available at the `1min`, `5min`, `15min`, and `30min` intervals for US equities. Open, high, low, close values are supplied without volume
    pub fn prepost(mut self, prepost: bool) -> Self {
        
        self.prepost = Some(prepost);
        
        self
    }
    /// The format of the response data
    pub fn format(mut self, format: impl Into<String>) -> Self {
        self.format = Some(format.into());
        
        self
    }
    /// The separator used in the CSV response data
    pub fn delimiter(mut self, delimiter: impl Into<String>) -> Self {
        self.delimiter = Some(delimiter.into());
        
        self
    }
    /// Specifies the number of decimal places for floating values. Should be in range [0, 11] inclusive. By default, the number of decimal places is automatically determined based on the values provided
    pub fn dp(mut self, dp: i64) -> Self {
        
        self.dp = Some(dp);
        
        self
    }
    /// A boolean parameter to include the previous closing price in the time_series data. If true, adds previous bar close price value to the current object
    pub fn previous_close(mut self, previous_close: bool) -> Self {
        
        self.previous_close = Some(previous_close);
        
        self
    }
    /// Adjusting mode for prices
    pub fn adjust(mut self, adjust: impl Into<String>) -> Self {
        self.adjust = Some(adjust.into());
        
        self
    }
    /// Price type on which technical indicator is calculated
    pub fn series_type(mut self, series_type: impl Into<String>) -> Self {
        self.series_type = Some(series_type.into());
        
        self
    }
    /// Number of periods to average over. Takes values in the range from `1` to `800`
    pub fn time_period(mut self, time_period: i64) -> Self {
        
        self.time_period = Some(time_period);
        
        self
    }
    /// Specify if OHLC values should be added in the output
    pub fn include_ohlc(mut self, include_ohlc: bool) -> Self {
        
        self.include_ohlc = Some(include_ohlc);
        
        self
    }

    /// Build the parameter struct
    pub fn build(self) -> GetTimeSeriesWmaParams {
        GetTimeSeriesWmaParams {
            interval: self.interval,
            symbol: self.symbol,
            isin: self.isin,
            figi: self.figi,
            cusip: self.cusip,
            outputsize: self.outputsize,
            exchange: self.exchange,
            mic_code: self.mic_code,
            country: self.country,
            r#type: self.r#type,
            timezone: self.timezone,
            start_date: self.start_date,
            end_date: self.end_date,
            date: self.date,
            order: self.order,
            prepost: self.prepost,
            format: self.format,
            delimiter: self.delimiter,
            dp: self.dp,
            previous_close: self.previous_close,
            adjust: self.adjust,
            series_type: self.series_type,
            time_period: self.time_period,
            include_ohlc: self.include_ohlc
        }
    }
}


/// struct for typed errors of method [`get_time_series_ad`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ad_osc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAdOscError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_adx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAdxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_adxr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAdxrError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_apo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesApoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_aroon`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAroonError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_aroon_osc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAroonOscError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_atr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAtrError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_avg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAvgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_avg_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesAvgPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_b_bands`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesBBandsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_beta`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesBetaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_bop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesBopError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_cci`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCciError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ceil`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCeilError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_cmo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCmoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_coppock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCoppockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_correl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCorrelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_crsi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesCrsiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_dema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesDemaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_div`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesDivError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_dpo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesDpoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_dx`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesDxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesEmaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_exp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesExpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_floor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesFloorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_heikinashi_candles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHeikinashiCandlesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_hlc3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHlc3Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_dc_period`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtDcPeriodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_dc_phase`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtDcPhaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_phasor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtPhasorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_sine`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtSineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_trend_mode`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtTrendModeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ht_trendline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesHtTrendlineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ichimoku`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesIchimokuError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_kama`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesKamaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_keltner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesKeltnerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_kst`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesKstError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_linear_reg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLinearRegError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_linear_reg_angle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLinearRegAngleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_linear_reg_intercept`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLinearRegInterceptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_linear_reg_slope`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLinearRegSlopeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ln`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_log10`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesLog10Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ma`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_macd`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMacdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_macd_ext`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMacdExtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_macd_slope`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMacdSlopeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mama`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMamaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_max`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMaxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_max_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMaxIndexError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mc_ginley_dynamic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMcGinleyDynamicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_med_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMedPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mfi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMfiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mid_point`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMidPointError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mid_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMidPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_min`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_min_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinIndexError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_min_max`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinMaxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_min_max_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinMaxIndexError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_minus_di`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinusDiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_minus_dm`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMinusDmError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mom`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_mult`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesMultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_natr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesNatrError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_obv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesObvError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_percent_b`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesPercentBError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_pivot_points_hl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesPivotPointsHlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_plus_di`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesPlusDiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_plus_dm`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesPlusDmError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ppo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesPpoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_roc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRocError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_rocp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRocpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_rocr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRocrError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_rocr100`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRocr100Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_rsi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRsiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_rvol`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesRvolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sar_ext`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSarExtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sma`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSmaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sqrt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSqrtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_std_dev`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesStdDevError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_stoch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesStochError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_stoch_f`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesStochFError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_stoch_rsi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesStochRsiError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sub`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSubError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_sum`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSumError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_super_trend`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSuperTrendError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_super_trend_heikin_ashi_candles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesSuperTrendHeikinAshiCandlesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_t3ma`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesT3maError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_t_range`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesTRangeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_tema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesTemaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_trima`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesTrimaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_tsf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesTsfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_typ_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesTypPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_ult_osc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesUltOscError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_var`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesVarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_vwap`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesVwapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_wcl_price`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesWclPriceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_will_r`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesWillRError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_series_wma`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeSeriesWmaError {
    UnknownValue(serde_json::Value),
}


/// The Accumulation/Distribution (AD) endpoint provides data on the cumulative money flow into and out of a financial instrument, using its closing price, price range, and trading volume. This endpoint returns the AD line, which helps users identify potential buying or selling pressure and assess the strength of price movements.
pub async fn get_time_series_ad(configuration: &configuration::Configuration, params: GetTimeSeriesAdParams) -> Result<models::GetTimeSeriesAd200Response, Error<GetTimeSeriesAdError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ad", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Accumulation/Distribution Oscillator endpoint (ADOSC) calculates a momentum indicator that highlights shifts in buying or selling pressure by analyzing price and volume data over different time frames. It returns numerical values that help users identify potential trend reversals in financial markets.
pub async fn get_time_series_ad_osc(configuration: &configuration::Configuration, params: GetTimeSeriesAdOscParams) -> Result<models::GetTimeSeriesAdOsc200Response, Error<GetTimeSeriesAdOscError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_fast_period = params.fast_period;
    let p_query_slow_period = params.slow_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/adosc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAdOsc200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAdOsc200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAdOscError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Addition (ADD) endpoint calculates the sum of two input data series, such as technical indicators or price data, and returns the combined result. This endpoint is useful for users who need to aggregate data points to create custom indicators or analyze the combined effect of multiple data series in financial analysis.
pub async fn get_time_series_add(configuration: &configuration::Configuration, params: GetTimeSeriesAddParams) -> Result<models::GetTimeSeriesAdd200Response, Error<GetTimeSeriesAddError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/add", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAdd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAdd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Average Directional Index (ADX) endpoint provides data on the strength of a market trend, regardless of its direction. It returns a numerical value that helps users identify whether a market is trending or moving sideways.
pub async fn get_time_series_adx(configuration: &configuration::Configuration, params: GetTimeSeriesAdxParams) -> Result<models::GetTimeSeriesAdx200Response, Error<GetTimeSeriesAdxError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/adx", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAdx200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAdx200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAdxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Average Directional Movement Index Rating (ADXR) endpoint provides a smoothed measure of trend strength for a specified financial instrument. It returns the ADXR values, which help users assess the consistency of a trend over a given period by reducing short-term fluctuations. This endpoint is useful for traders and analysts who need to evaluate the stability of market trends for better timing of entry and exit points in their trading strategies.
pub async fn get_time_series_adxr(configuration: &configuration::Configuration, params: GetTimeSeriesAdxrParams) -> Result<models::GetTimeSeriesAdxr200Response, Error<GetTimeSeriesAdxrError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/adxr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAdxr200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAdxr200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAdxrError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Absolute Price Oscillator (APO) endpoint calculates the difference between two specified moving averages of a financial instrument's price, providing data that helps users identify potential price trends and reversals. The response includes the calculated APO values over a specified time period, which can be used to track momentum changes and assess the strength of price movements.
pub async fn get_time_series_apo(configuration: &configuration::Configuration, params: GetTimeSeriesApoParams) -> Result<models::GetTimeSeriesApo200Response, Error<GetTimeSeriesApoError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_period = params.fast_period;
    let p_query_slow_period = params.slow_period;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/apo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesApo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesApo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesApoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Aroon Indicator endpoint provides data on the time elapsed since the highest high and lowest low within a specified period, helping users identify the presence and strength of market trends. It returns two values: Aroon Up and Aroon Down, which indicate the trend direction and momentum. This endpoint is useful for traders and analysts looking to assess trend patterns and potential reversals in financial markets.
pub async fn get_time_series_aroon(configuration: &configuration::Configuration, params: GetTimeSeriesAroonParams) -> Result<models::GetTimeSeriesAroon200Response, Error<GetTimeSeriesAroonError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/aroon", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAroon200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAroon200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAroonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Aroon Oscillator endpoint provides the calculated difference between the Aroon Up and Aroon Down indicators for a given financial instrument. It returns a time series of values that help users identify the strength and direction of a trend, as well as potential trend reversals. This data is useful for traders and analysts seeking to evaluate market trends over a specified period.
pub async fn get_time_series_aroon_osc(configuration: &configuration::Configuration, params: GetTimeSeriesAroonOscParams) -> Result<models::GetTimeSeriesAroonOsc200Response, Error<GetTimeSeriesAroonOscError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/aroonosc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAroonOsc200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAroonOsc200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAroonOscError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Average True Range (ATR) endpoint provides data on market volatility by calculating the average range of price movement over a user-defined period. It returns numerical values representing the ATR for each time interval, allowing users to gauge the degree of price fluctuation in a financial instrument. This data is useful for setting stop-loss levels and determining optimal entry and exit points in trading strategies.
pub async fn get_time_series_atr(configuration: &configuration::Configuration, params: GetTimeSeriesAtrParams) -> Result<models::GetTimeSeriesAtr200Response, Error<GetTimeSeriesAtrError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/atr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAtr200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAtr200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAtrError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Average (AVG) endpoint calculates the arithmetic mean of a specified data series over a chosen time period. It returns a smoothed dataset that helps users identify trends by reducing short-term fluctuations. This endpoint is useful for obtaining a clearer view of data trends, particularly in time series analysis.
pub async fn get_time_series_avg(configuration: &configuration::Configuration, params: GetTimeSeriesAvgParams) -> Result<models::GetTimeSeriesAvg200Response, Error<GetTimeSeriesAvgError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/avg", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAvg200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAvg200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAvgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Average Price (AVGPRICE) endpoint calculates and returns the mean value of a security's open, high, low, and close prices. This endpoint provides a straightforward metric to assess the overall price level of a security over a specified period.
pub async fn get_time_series_avg_price(configuration: &configuration::Configuration, params: GetTimeSeriesAvgPriceParams) -> Result<models::GetTimeSeriesAvgPrice200Response, Error<GetTimeSeriesAvgPriceError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/avgprice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesAvgPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesAvgPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesAvgPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Bollinger Bands (BBANDS) endpoint calculates and returns three key data points: an upper band, a lower band, and a simple moving average (SMA) for a specified financial instrument. These bands are used to assess market volatility by showing how far prices deviate from the SMA. This information helps users identify potential price reversals and determine whether an asset is overbought or oversold.
pub async fn get_time_series_b_bands(configuration: &configuration::Configuration, params: GetTimeSeriesBBandsParams) -> Result<models::GetTimeSeriesBBands200Response, Error<GetTimeSeriesBBandsError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_sd = params.sd;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/bbands", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sd {
        req_builder = req_builder.query(&[("sd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesBBands200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesBBands200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesBBandsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Beta Indicator endpoint provides data on a security's sensitivity to market movements by comparing its price changes to a benchmark index. It returns the beta value, which quantifies the systematic risk of the security relative to the market. This information is useful for evaluating how much a security's price is expected to move in relation to market changes.
pub async fn get_time_series_beta(configuration: &configuration::Configuration, params: GetTimeSeriesBetaParams) -> Result<models::GetTimeSeriesBeta200Response, Error<GetTimeSeriesBetaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/beta", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesBeta200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesBeta200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesBetaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Balance of Power (BOP) endpoint provides data on the buying and selling pressure of a security by analyzing its open, high, low, and close prices. It returns numerical values that help users detect shifts in market sentiment and potential price movements.
pub async fn get_time_series_bop(configuration: &configuration::Configuration, params: GetTimeSeriesBopParams) -> Result<models::GetTimeSeriesBop200Response, Error<GetTimeSeriesBopError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/bop", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesBop200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesBop200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesBopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Commodity Channel Index (CCI) endpoint provides data on the CCI values for a specified security, helping users detect potential price reversals by identifying overbought or oversold conditions. It returns a series of CCI values calculated over a specified time period, allowing users to assess the momentum of a security relative to its average price range.
pub async fn get_time_series_cci(configuration: &configuration::Configuration, params: GetTimeSeriesCciParams) -> Result<models::GetTimeSeriesCci200Response, Error<GetTimeSeriesCciError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/cci", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCci200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCci200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCciError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Ceiling (CEIL) endpoint rounds each value in the input data series up to the nearest whole number. It returns a series where each original data point is adjusted to its ceiling value, which can be useful for precise calculations or when integrating with other technical indicators that require integer inputs.
pub async fn get_time_series_ceil(configuration: &configuration::Configuration, params: GetTimeSeriesCeilParams) -> Result<models::GetTimeSeriesCeil200Response, Error<GetTimeSeriesCeilError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ceil", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCeil200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCeil200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCeilError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Chande Momentum Oscillator (CMO) endpoint provides data on the momentum of a security by calculating the relative strength of recent price movements. It returns a numerical value indicating whether a security is potentially overbought or oversold, assisting users in identifying possible trend reversals.
pub async fn get_time_series_cmo(configuration: &configuration::Configuration, params: GetTimeSeriesCmoParams) -> Result<models::GetTimeSeriesCmo200Response, Error<GetTimeSeriesCmoError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/cmo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCmo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCmo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCmoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Coppock Curve is a momentum oscillator used to detect potential long-term trend reversals in financial markets. It returns the calculated values of this indicator over a specified period, allowing users to identify when a security's price may be shifting from a downtrend to an uptrend. This endpoint is particularly useful for analyzing securities in bottoming markets.
pub async fn get_time_series_coppock(configuration: &configuration::Configuration, params: GetTimeSeriesCoppockParams) -> Result<models::GetTimeSeriesCoppock200Response, Error<GetTimeSeriesCoppockError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_wma_period = params.wma_period;
    let p_query_long_roc_period = params.long_roc_period;
    let p_query_short_roc_period = params.short_roc_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/coppock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_wma_period {
        req_builder = req_builder.query(&[("wma_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_long_roc_period {
        req_builder = req_builder.query(&[("long_roc_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_short_roc_period {
        req_builder = req_builder.query(&[("short_roc_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCoppock200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCoppock200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCoppockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Correlation (CORREL) endpoint calculates the statistical relationship between two securities over a specified time period, returning a correlation coefficient. This coefficient ranges from -1 to 1, indicating the strength and direction of their linear relationship. A value close to 1 suggests a strong positive correlation, while a value near -1 indicates a strong negative correlation. This data is useful for identifying securities that move together or in opposite directions, aiding in strategies like diversification or pairs trading.
pub async fn get_time_series_correl(configuration: &configuration::Configuration, params: GetTimeSeriesCorrelParams) -> Result<models::GetTimeSeriesCorrel200Response, Error<GetTimeSeriesCorrelError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/correl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCorrel200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCorrel200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCorrelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Connors Relative Strength Index (CRSI) endpoint provides a detailed analysis of stock momentum by combining three components: the Relative Strength Index, the Rate of Change, and the Up/Down Length. This endpoint returns a numerical value that helps identify potential trend reversals and momentum shifts in a security's price. Ideal for traders seeking to refine entry and exit points, the CRSI offers a nuanced view of market conditions beyond traditional RSI indicators.
pub async fn get_time_series_crsi(configuration: &configuration::Configuration, params: GetTimeSeriesCrsiParams) -> Result<models::GetTimeSeriesCrsi200Response, Error<GetTimeSeriesCrsiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_rsi_period = params.rsi_period;
    let p_query_up_down_length = params.up_down_length;
    let p_query_percent_rank_period = params.percent_rank_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/crsi", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_rsi_period {
        req_builder = req_builder.query(&[("rsi_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_up_down_length {
        req_builder = req_builder.query(&[("up_down_length", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_percent_rank_period {
        req_builder = req_builder.query(&[("percent_rank_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesCrsi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesCrsi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesCrsiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Double Exponential Moving Average (DEMA) endpoint provides a data series that calculates a moving average with reduced lag by emphasizing recent price data. This endpoint returns time-series data that includes the DEMA values for a specified financial instrument, allowing users to track price trends and identify potential trading opportunities.
pub async fn get_time_series_dema(configuration: &configuration::Configuration, params: GetTimeSeriesDemaParams) -> Result<models::GetTimeSeriesDema200Response, Error<GetTimeSeriesDemaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/dema", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesDema200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesDema200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesDemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Division (DIV) endpoint calculates the result of dividing one data series by another, providing a normalized output. It is commonly used to combine or adjust multiple technical indicators or price data for comparative analysis. This endpoint returns the division results as a time series, allowing users to easily interpret and utilize the normalized data in their financial models or charts.
pub async fn get_time_series_div(configuration: &configuration::Configuration, params: GetTimeSeriesDivParams) -> Result<models::GetTimeSeriesDiv200Response, Error<GetTimeSeriesDivError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/div", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesDiv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesDiv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesDivError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Detrended Price Oscillator (DPO) endpoint calculates and returns the DPO values for a specified financial instrument over a given time period. This endpoint helps traders by highlighting short-term price cycles and identifying potential overbought or oversold conditions without the influence of long-term trends. The response includes a series of DPO values, which can be used to assess price momentum and cyclical patterns in the market.
pub async fn get_time_series_dpo(configuration: &configuration::Configuration, params: GetTimeSeriesDpoParams) -> Result<models::GetTimeSeriesDpo200Response, Error<GetTimeSeriesDpoError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_centered = params.centered;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/dpo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_centered {
        req_builder = req_builder.query(&[("centered", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesDpo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesDpo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesDpoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the Directional Movement Index (DX) values for a given security to assess the strength of its positive and negative price movements. This endpoint provides a time series of DX values, which are useful for evaluating the momentum and trend direction of the security over a specified period.
pub async fn get_time_series_dx(configuration: &configuration::Configuration, params: GetTimeSeriesDxParams) -> Result<models::GetTimeSeriesDx200Response, Error<GetTimeSeriesDxError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/dx", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesDx200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesDx200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesDxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Exponential Moving Average (EMA) endpoint calculates the EMA for a specified financial instrument over a given time period. It returns a time series of EMA values, which highlight recent price trends by weighting recent data more heavily. This is useful for traders seeking to identify trend directions and potential trade opportunities based on recent price movements.
pub async fn get_time_series_ema(configuration: &configuration::Configuration, params: GetTimeSeriesEmaParams) -> Result<models::GetTimeSeriesEma200Response, Error<GetTimeSeriesEmaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ema", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesEma200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesEma200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesEmaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Exponential (EXP) Indicator endpoint computes the exponential value of a specified input, providing a numerical result that is commonly applied in complex mathematical and financial computations.
pub async fn get_time_series_exp(configuration: &configuration::Configuration, params: GetTimeSeriesExpParams) -> Result<models::GetTimeSeriesExp200Response, Error<GetTimeSeriesExpError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/exp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesExp200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesExp200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesExpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Floor (FLOOR) endpoint processes numerical input data by rounding each value down to the nearest integer. It returns a series of adjusted data points that can be used for further calculations or combined with other datasets. This endpoint is useful for users needing to simplify data by removing decimal precision, aiding in scenarios where integer values are required.
pub async fn get_time_series_floor(configuration: &configuration::Configuration, params: GetTimeSeriesFloorParams) -> Result<models::GetTimeSeriesFloor200Response, Error<GetTimeSeriesFloorError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/floor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesFloor200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesFloor200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesFloorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The heikinashi candles endpoint provides smoothed candlestick data by averaging price information to reduce market noise. It returns a series of Heikin Ashi candles, which include open, high, low, and close values, making it easier to identify trends and potential reversals in asset prices. This endpoint is useful for traders and analysts seeking a clearer view of market trends without the volatility present in traditional candlestick charts.
pub async fn get_time_series_heikinashi_candles(configuration: &configuration::Configuration, params: GetTimeSeriesHeikinashiCandlesParams) -> Result<models::GetTimeSeriesHeikinashiCandles200Response, Error<GetTimeSeriesHeikinashiCandlesError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/heikinashicandles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHeikinashiCandles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHeikinashiCandles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHeikinashiCandlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The High, Low, Close Average (HLC3) endpoint calculates and returns the average of a security's high, low, and close prices for a specified period. This endpoint provides a straightforward metric to assess price trends, helping users quickly identify the average price level of a security over time.
pub async fn get_time_series_hlc3(configuration: &configuration::Configuration, params: GetTimeSeriesHlc3Params) -> Result<models::GetTimeSeriesHlc3200Response, Error<GetTimeSeriesHlc3Error>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/hlc3", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHlc3200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHlc3200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHlc3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Dominant Cycle Period (HT_DCPERIOD) endpoint calculates the dominant cycle length of a financial instrument's price data. It returns a numerical value representing the cycle period, which traders can use to identify prevailing market cycles and adjust their trading strategies accordingly.
pub async fn get_time_series_ht_dc_period(configuration: &configuration::Configuration, params: GetTimeSeriesHtDcPeriodParams) -> Result<models::GetTimeSeriesHtDcPeriod200Response, Error<GetTimeSeriesHtDcPeriodError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_dcperiod", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtDcPeriod200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtDcPeriod200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtDcPeriodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Dominant Cycle Phase (HT_DCPHASE) endpoint provides the current phase of the dominant market cycle for a given financial instrument. It returns numerical data indicating the phase angle, which can be used by traders to identify potential market entry and exit points based on cyclical patterns.
pub async fn get_time_series_ht_dc_phase(configuration: &configuration::Configuration, params: GetTimeSeriesHtDcPhaseParams) -> Result<models::GetTimeSeriesHtDcPhase200Response, Error<GetTimeSeriesHtDcPhaseError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_dcphase", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtDcPhase200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtDcPhase200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtDcPhaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Phasor Components (HT_PHASOR) endpoint analyzes a price series to return two key components: in-phase and quadrature. These components help identify cyclical patterns and the direction of trends in the data. Use this endpoint to gain precise insights into the timing and strength of market cycles, enhancing your ability to track and predict price movements.
pub async fn get_time_series_ht_phasor(configuration: &configuration::Configuration, params: GetTimeSeriesHtPhasorParams) -> Result<models::GetTimeSeriesHtPhasor200Response, Error<GetTimeSeriesHtPhasorError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_phasor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtPhasor200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtPhasor200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtPhasorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Sine Wave (HT_SINE) endpoint provides sine and cosine wave components derived from the dominant market cycle. This data helps traders pinpoint potential market turning points and assess trend directions by analyzing cyclical patterns.
pub async fn get_time_series_ht_sine(configuration: &configuration::Configuration, params: GetTimeSeriesHtSineParams) -> Result<models::GetTimeSeriesHtSine200Response, Error<GetTimeSeriesHtSineError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_sine", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtSine200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtSine200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtSineError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Trend vs Cycle Mode (HT_TRENDMODE) endpoint identifies whether a market is in a trending or cyclical phase. It returns data indicating the current market phase, allowing users to adjust their trading strategies based on the prevailing conditions.
pub async fn get_time_series_ht_trend_mode(configuration: &configuration::Configuration, params: GetTimeSeriesHtTrendModeParams) -> Result<models::GetTimeSeriesHtTrendMode200Response, Error<GetTimeSeriesHtTrendModeError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_trendmode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtTrendMode200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtTrendMode200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtTrendModeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Hilbert Transform Instantaneous Trendline (HT_TRENDLINE) endpoint provides a smoothed moving average that aligns with the dominant market cycle. It returns data points that help traders identify current market trends and determine potential entry or exit points in trading.
pub async fn get_time_series_ht_trendline(configuration: &configuration::Configuration, params: GetTimeSeriesHtTrendlineParams) -> Result<models::GetTimeSeriesHtTrendline200Response, Error<GetTimeSeriesHtTrendlineError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ht_trendline", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesHtTrendline200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesHtTrendline200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesHtTrendlineError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Ichimoku Cloud endpoint provides data on the Ichimoku Kinko Hyo indicator, offering insights into trend direction, support and resistance levels, and potential entry and exit points. It returns key components such as the Tenkan-sen, Kijun-sen, Senkou Span A, Senkou Span B, and Chikou Span. This data helps users evaluate market trends and identify strategic trading opportunities.
pub async fn get_time_series_ichimoku(configuration: &configuration::Configuration, params: GetTimeSeriesIchimokuParams) -> Result<models::GetTimeSeriesIchimoku200Response, Error<GetTimeSeriesIchimokuError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_conversion_line_period = params.conversion_line_period;
    let p_query_base_line_period = params.base_line_period;
    let p_query_leading_span_b_period = params.leading_span_b_period;
    let p_query_lagging_span_period = params.lagging_span_period;
    let p_query_include_ahead_span_period = params.include_ahead_span_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ichimoku", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_conversion_line_period {
        req_builder = req_builder.query(&[("conversion_line_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_base_line_period {
        req_builder = req_builder.query(&[("base_line_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_leading_span_b_period {
        req_builder = req_builder.query(&[("leading_span_b_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_lagging_span_period {
        req_builder = req_builder.query(&[("lagging_span_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ahead_span_period {
        req_builder = req_builder.query(&[("include_ahead_span_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesIchimoku200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesIchimoku200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesIchimokuError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Kaufman Adaptive Moving Average (KAMA) endpoint calculates the KAMA for a specified financial instrument, returning a time series of values that reflect the average price adjusted for market volatility. This endpoint helps users identify trends by smoothing out price fluctuations while remaining sensitive to significant price movements.
pub async fn get_time_series_kama(configuration: &configuration::Configuration, params: GetTimeSeriesKamaParams) -> Result<models::GetTimeSeriesKama200Response, Error<GetTimeSeriesKamaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/kama", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesKama200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesKama200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesKamaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Keltner Channel endpoint provides data for a volatility-based technical indicator that combines the Exponential Moving Average (EMA) and the Average True Range (ATR) to form a channel around a security's price. This endpoint returns the upper, middle, and lower bands of the channel, which can be used to identify potential overbought or oversold conditions, assess trend direction, and detect possible price breakouts.
pub async fn get_time_series_keltner(configuration: &configuration::Configuration, params: GetTimeSeriesKeltnerParams) -> Result<models::GetTimeSeriesKeltner200Response, Error<GetTimeSeriesKeltnerError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_atr_time_period = params.atr_time_period;
    let p_query_multiplier = params.multiplier;
    let p_query_series_type = params.series_type;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/keltner", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_atr_time_period {
        req_builder = req_builder.query(&[("atr_time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multiplier {
        req_builder = req_builder.query(&[("multiplier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesKeltner200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesKeltner200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesKeltnerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Know Sure Thing (KST) endpoint provides a momentum oscillator that combines four smoothed rates of change into a single trend-following indicator. This endpoint returns data that helps users identify potential trend reversals, as well as overbought or oversold conditions in the market.
pub async fn get_time_series_kst(configuration: &configuration::Configuration, params: GetTimeSeriesKstParams) -> Result<models::GetTimeSeriesKst200Response, Error<GetTimeSeriesKstError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_roc_period_1 = params.roc_period_1;
    let p_query_roc_period_2 = params.roc_period_2;
    let p_query_roc_period_3 = params.roc_period_3;
    let p_query_roc_period_4 = params.roc_period_4;
    let p_query_sma_period_1 = params.sma_period_1;
    let p_query_sma_period_2 = params.sma_period_2;
    let p_query_sma_period_3 = params.sma_period_3;
    let p_query_sma_period_4 = params.sma_period_4;
    let p_query_signal_period = params.signal_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/kst", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_roc_period_1 {
        req_builder = req_builder.query(&[("roc_period_1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_roc_period_2 {
        req_builder = req_builder.query(&[("roc_period_2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_roc_period_3 {
        req_builder = req_builder.query(&[("roc_period_3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_roc_period_4 {
        req_builder = req_builder.query(&[("roc_period_4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sma_period_1 {
        req_builder = req_builder.query(&[("sma_period_1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sma_period_2 {
        req_builder = req_builder.query(&[("sma_period_2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sma_period_3 {
        req_builder = req_builder.query(&[("sma_period_3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sma_period_4 {
        req_builder = req_builder.query(&[("sma_period_4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signal_period {
        req_builder = req_builder.query(&[("signal_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesKst200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesKst200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesKstError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Linear Regression endpoint (LINEARREG) calculates the best-fit straight line through a series of financial data points. It returns the slope and intercept values of this line, allowing users to determine the overall direction of a market trend and identify potential support or resistance levels.
pub async fn get_time_series_linear_reg(configuration: &configuration::Configuration, params: GetTimeSeriesLinearRegParams) -> Result<models::GetTimeSeriesLinearReg200Response, Error<GetTimeSeriesLinearRegError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/linearreg", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLinearReg200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLinearReg200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLinearRegError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Linear Regression Angle endpoint (LINEARREGANGLE) calculates the angle of the linear regression line for a given time series of stock prices. It returns the slope of the trend line, expressed in degrees, which helps users identify the direction and steepness of a trend over a specified period. This data is useful for detecting upward or downward trends in asset prices.
pub async fn get_time_series_linear_reg_angle(configuration: &configuration::Configuration, params: GetTimeSeriesLinearRegAngleParams) -> Result<models::GetTimeSeriesLinearRegAngle200Response, Error<GetTimeSeriesLinearRegAngleError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/linearregangle", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLinearRegAngle200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLinearRegAngle200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLinearRegAngleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Linear Regression Intercept endpoint (LINEARREGINTERCEPT) calculates the y-intercept of a linear regression line for a given dataset. It returns the value where the regression line crosses the y-axis, providing a numerical reference point for understanding the starting position of a trend over a specified period. This can be useful for users needing to establish baseline values in their data analysis.
pub async fn get_time_series_linear_reg_intercept(configuration: &configuration::Configuration, params: GetTimeSeriesLinearRegInterceptParams) -> Result<models::GetTimeSeriesLinearRegIntercept200Response, Error<GetTimeSeriesLinearRegInterceptError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/linearregintercept", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLinearRegIntercept200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLinearRegIntercept200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLinearRegInterceptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Linear Regression Slope endpoint (LINEARREGSLOPE) calculates the slope of a linear regression line for a given dataset, reflecting the rate of change in the data trend over a specified period. It returns a numerical value representing this slope, which can be used to assess the direction and strength of the trend in the dataset.
pub async fn get_time_series_linear_reg_slope(configuration: &configuration::Configuration, params: GetTimeSeriesLinearRegSlopeParams) -> Result<models::GetTimeSeriesLinearRegSlope200Response, Error<GetTimeSeriesLinearRegSlopeError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/linearregslope", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLinearRegSlope200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLinearRegSlope200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLinearRegSlopeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Natural Logarithm (LN) endpoint computes the natural logarithm of a specified input value, returning a numerical result. This endpoint is useful for users needing to perform logarithmic transformations on data, which can be applied in various financial calculations and advanced mathematical analyses.
pub async fn get_time_series_ln(configuration: &configuration::Configuration, params: GetTimeSeriesLnParams) -> Result<models::GetTimeSeriesLn200Response, Error<GetTimeSeriesLnError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ln", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLn200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLn200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Base-10 Logarithm (LOG10) endpoint computes the base-10 logarithm of a specified input value. It returns a numerical result that represents the power to which the number 10 must be raised to obtain the input value. This endpoint is useful for transforming data into a logarithmic scale, which can simplify the analysis of exponential growth patterns or compress large ranges of data in financial calculations.
pub async fn get_time_series_log10(configuration: &configuration::Configuration, params: GetTimeSeriesLog10Params) -> Result<models::GetTimeSeriesLog10200Response, Error<GetTimeSeriesLog10Error>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/log10", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesLog10200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesLog10200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesLog10Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Moving Average (MA) endpoint provides the average price of a security over a specified time frame, offering a smoothed representation of price data. This endpoint returns the calculated moving average values, which can assist users in identifying price trends and potential support or resistance levels in the market.
pub async fn get_time_series_ma(configuration: &configuration::Configuration, params: GetTimeSeriesMaParams) -> Result<models::GetTimeSeriesMa200Response, Error<GetTimeSeriesMaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ma", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMa200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMa200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint calculates the Moving Average Convergence Divergence (MACD) for a specified financial instrument. It returns the MACD line, signal line, and histogram values, which help users identify potential trend reversals and trading opportunities by analyzing the relationship between two moving averages.
pub async fn get_time_series_macd(configuration: &configuration::Configuration, params: GetTimeSeriesMacdParams) -> Result<models::GetTimeSeriesMacd200Response, Error<GetTimeSeriesMacdError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_period = params.fast_period;
    let p_query_slow_period = params.slow_period;
    let p_query_signal_period = params.signal_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/macd", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signal_period {
        req_builder = req_builder.query(&[("signal_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMacd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMacd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMacdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Moving Average Convergence Divergence Extension (MACDEXT) endpoint provides a customizable version of the MACD indicator, allowing users to specify different moving average types and parameters. It returns data that includes the MACD line, signal line, and histogram values, tailored to the user's chosen settings. This endpoint is useful for traders who require flexibility in analyzing price trends and momentum by adjusting the calculation methods to fit their specific trading strategies.
pub async fn get_time_series_macd_ext(configuration: &configuration::Configuration, params: GetTimeSeriesMacdExtParams) -> Result<models::GetTimeSeriesMacdExt200Response, Error<GetTimeSeriesMacdExtError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_period = params.fast_period;
    let p_query_fast_ma_type = params.fast_ma_type;
    let p_query_slow_period = params.slow_period;
    let p_query_slow_ma_type = params.slow_ma_type;
    let p_query_signal_period = params.signal_period;
    let p_query_signal_ma_type = params.signal_ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/macdext", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fast_ma_type {
        req_builder = req_builder.query(&[("fast_ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_ma_type {
        req_builder = req_builder.query(&[("slow_ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_signal_period {
        req_builder = req_builder.query(&[("signal_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signal_ma_type {
        req_builder = req_builder.query(&[("signal_ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMacdExt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMacdExt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMacdExtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Moving Average Convergence Divergence (MACD) Slope endpoint provides the rate of change of the MACD line for a given security. It returns data on how quickly the MACD line is rising or falling, offering insights into the momentum shifts in the security's price. This information is useful for traders looking to gauge the speed of price movements and potential trend reversals.
pub async fn get_time_series_macd_slope(configuration: &configuration::Configuration, params: GetTimeSeriesMacdSlopeParams) -> Result<models::GetTimeSeriesMacdSlope200Response, Error<GetTimeSeriesMacdSlopeError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_period = params.fast_period;
    let p_query_slow_period = params.slow_period;
    let p_query_signal_period = params.signal_period;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/macd_slope", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signal_period {
        req_builder = req_builder.query(&[("signal_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMacdSlope200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMacdSlope200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMacdSlopeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The MESA Adaptive Moving Average (MAMA) endpoint calculates a moving average that adjusts to the dominant market cycle, offering a balance between quick response to price changes and noise reduction. It returns data that includes the adaptive moving average values, which can be used to identify trends and potential reversal points.
pub async fn get_time_series_mama(configuration: &configuration::Configuration, params: GetTimeSeriesMamaParams) -> Result<models::GetTimeSeriesMama200Response, Error<GetTimeSeriesMamaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_limit = params.fast_limit;
    let p_query_slow_limit = params.slow_limit;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/mama", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_limit {
        req_builder = req_builder.query(&[("fast_limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_limit {
        req_builder = req_builder.query(&[("slow_limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMama200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMama200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMamaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Maximum (MAX) endpoint calculates and returns the highest value within a specified data series over a given period. This endpoint is useful for identifying potential resistance levels or detecting extreme price movements in financial data.
pub async fn get_time_series_max(configuration: &configuration::Configuration, params: GetTimeSeriesMaxParams) -> Result<models::GetTimeSeriesMax200Response, Error<GetTimeSeriesMaxError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/max", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMax200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMax200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMaxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Maximum Index (MAXINDEX) endpoint identifies the position of the highest value within a specified data series over a given time frame. It returns the index where the peak value occurs, allowing users to pinpoint when the maximum price or value was reached in the series. This is useful for tracking the timing of significant peaks in financial data.
pub async fn get_time_series_max_index(configuration: &configuration::Configuration, params: GetTimeSeriesMaxIndexParams) -> Result<models::GetTimeSeriesMaxIndex200Response, Error<GetTimeSeriesMaxIndexError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/maxindex", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMaxIndex200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMaxIndex200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMaxIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint calculates the McGinley Dynamic (MCGINLEY_DYNAMIC) indicator, which provides a refined moving average that adapts to market volatility. This endpoint returns data that reflects smoother price trends and identifies potential support or resistance levels more accurately than traditional moving averages. It is useful for users seeking to track price movements with reduced lag and enhanced responsiveness to market changes.
pub async fn get_time_series_mc_ginley_dynamic(configuration: &configuration::Configuration, params: GetTimeSeriesMcGinleyDynamicParams) -> Result<models::GetTimeSeriesMcGinleyDynamic200Response, Error<GetTimeSeriesMcGinleyDynamicError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/mcginley_dynamic", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMcGinleyDynamic200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMcGinleyDynamic200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMcGinleyDynamicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Median Price (MEDPRICE) endpoint calculates and returns the average of the high and low prices of a security for a specified period. This endpoint provides a simplified view of price movements, helping users quickly assess price trends by focusing on the midpoint of price action.
pub async fn get_time_series_med_price(configuration: &configuration::Configuration, params: GetTimeSeriesMedPriceParams) -> Result<models::GetTimeSeriesMedPrice200Response, Error<GetTimeSeriesMedPriceError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/medprice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMedPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMedPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMedPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Money Flow Index (MFI) endpoint provides a volume-weighted momentum oscillator that quantifies buying and selling pressure by analyzing positive and negative money flow. It returns data indicating potential overbought or oversold conditions in a financial asset, aiding users in understanding market trends and price movements.
pub async fn get_time_series_mfi(configuration: &configuration::Configuration, params: GetTimeSeriesMfiParams) -> Result<models::GetTimeSeriesMfi200Response, Error<GetTimeSeriesMfiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/mfi", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMfi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMfi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMfiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Midpoint (MIDPOINT) endpoint calculates the average value between the highest and lowest prices of a financial instrument over a specified period. It returns a time series of midpoint values, which can help users identify price trends and smooth out short-term fluctuations in the data.
pub async fn get_time_series_mid_point(configuration: &configuration::Configuration, params: GetTimeSeriesMidPointParams) -> Result<models::GetTimeSeriesMidPoint200Response, Error<GetTimeSeriesMidPointError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/midpoint", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMidPoint200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMidPoint200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMidPointError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Midprice (MIDPRICE) endpoint calculates and returns the average of a financial instrument's highest and lowest prices over a specified time period. This data provides a smoothed representation of price movements, helping users identify potential support or resistance levels in the market.
pub async fn get_time_series_mid_price(configuration: &configuration::Configuration, params: GetTimeSeriesMidPriceParams) -> Result<models::GetTimeSeriesMidPrice200Response, Error<GetTimeSeriesMidPriceError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/midprice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMidPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMidPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMidPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minimum (MIN) Indicator endpoint provides the lowest value of a specified data series over a chosen time period. This endpoint is useful for identifying potential support levels or detecting extreme price movements in financial data.
pub async fn get_time_series_min(configuration: &configuration::Configuration, params: GetTimeSeriesMinParams) -> Result<models::GetTimeSeriesMin200Response, Error<GetTimeSeriesMinError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/min", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMin200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMin200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minimum Index (MININDEX) endpoint identifies the position of the lowest value within a specified data series over a given time frame. It returns the index number corresponding to the earliest occurrence of this minimum value. This is useful for pinpointing when the lowest price or value occurred in a dataset, aiding in time-based analysis of data trends.
pub async fn get_time_series_min_index(configuration: &configuration::Configuration, params: GetTimeSeriesMinIndexParams) -> Result<models::GetTimeSeriesMinIndex200Response, Error<GetTimeSeriesMinIndexError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/minindex", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMinIndex200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMinIndex200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minimum and Maximum (MINMAX) endpoint identifies the lowest and highest values within a specified time frame for a given data series. It returns these extreme values, which can be used to detect potential support and resistance levels or significant price fluctuations in the data.
pub async fn get_time_series_min_max(configuration: &configuration::Configuration, params: GetTimeSeriesMinMaxParams) -> Result<models::GetTimeSeriesMinMax200Response, Error<GetTimeSeriesMinMaxError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/minmax", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMinMax200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMinMax200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinMaxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minimum and Maximum Index (MINMAXINDEX) endpoint identifies the positions of the lowest and highest values within a specified data series period. It returns indices that indicate when these extreme values occur, allowing users to pinpoint significant price changes over time.
pub async fn get_time_series_min_max_index(configuration: &configuration::Configuration, params: GetTimeSeriesMinMaxIndexParams) -> Result<models::GetTimeSeriesMinMaxIndex200Response, Error<GetTimeSeriesMinMaxIndexError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/minmaxindex", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMinMaxIndex200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMinMaxIndex200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinMaxIndexError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minus Directional Indicator (MINUS_DI) endpoint calculates and returns the strength of a security's downward price movement over a specified period. This data is useful for traders and analysts looking to identify bearish trends and assess the intensity of price declines in financial markets.
pub async fn get_time_series_minus_di(configuration: &configuration::Configuration, params: GetTimeSeriesMinusDiParams) -> Result<models::GetTimeSeriesMinusDi200Response, Error<GetTimeSeriesMinusDiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/minus_di", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMinusDi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMinusDi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinusDiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Minus Directional Movement endpoint (MINUS_DM) calculates the downward price movement of a security over a specified period. It returns a series of values indicating the strength of downward trends, useful for traders to identify potential selling opportunities or confirm bearish market conditions.
pub async fn get_time_series_minus_dm(configuration: &configuration::Configuration, params: GetTimeSeriesMinusDmParams) -> Result<models::GetTimeSeriesMinusDm200Response, Error<GetTimeSeriesMinusDmError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/minus_dm", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMinusDm200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMinusDm200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMinusDmError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Momentum (MOM) endpoint provides data on the rate of change in a security's price over a user-defined period. It returns a series of numerical values indicating the speed and direction of the price movement, which can help users detect emerging trends or potential reversals in the market.
pub async fn get_time_series_mom(configuration: &configuration::Configuration, params: GetTimeSeriesMomParams) -> Result<models::GetTimeSeriesMom200Response, Error<GetTimeSeriesMomError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/mom", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMom200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMom200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMomError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Multiplication (MULT) endpoint calculates the product of two input data series, returning a new data series that represents the element-wise multiplication of the inputs. This is useful for combining or adjusting technical indicators or price data to create custom metrics or to normalize values across different scales.
pub async fn get_time_series_mult(configuration: &configuration::Configuration, params: GetTimeSeriesMultParams) -> Result<models::GetTimeSeriesMult200Response, Error<GetTimeSeriesMultError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/mult", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesMult200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesMult200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesMultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Normalized Average True Range (NATR) endpoint provides a volatility indicator that calculates the average range of price movement over a specified period, expressed as a percentage of the security's price. This data allows users to compare volatility levels across different securities easily. The endpoint returns a time series of NATR values, which can be used to assess and compare the price volatility of various financial instruments.
pub async fn get_time_series_natr(configuration: &configuration::Configuration, params: GetTimeSeriesNatrParams) -> Result<models::GetTimeSeriesNatr200Response, Error<GetTimeSeriesNatrError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/natr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesNatr200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesNatr200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesNatrError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The On Balance Volume (OBV) endpoint provides a time series of the OBV indicator, which calculates cumulative volume to reflect buying and selling pressure over time. This endpoint returns data that helps users track volume trends in relation to price movements, aiding in the identification of potential trend continuations or reversals in a security's price.
pub async fn get_time_series_obv(configuration: &configuration::Configuration, params: GetTimeSeriesObvParams) -> Result<models::GetTimeSeriesObv200Response, Error<GetTimeSeriesObvError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/obv", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesObv200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesObv200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesObvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Percent B (%B) endpoint calculates and returns the %B value, which indicates the position of a security's price relative to its Bollinger Bands. This data helps users determine if a security is near the upper or lower band, potentially signaling overbought or oversold conditions.
pub async fn get_time_series_percent_b(configuration: &configuration::Configuration, params: GetTimeSeriesPercentBParams) -> Result<models::GetTimeSeriesPercentB200Response, Error<GetTimeSeriesPercentBError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_sd = params.sd;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/percent_b", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sd {
        req_builder = req_builder.query(&[("sd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesPercentB200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesPercentB200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesPercentBError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Pivot Points High Low (PIVOT_POINTS_HL) endpoint calculates key support and resistance levels for a security by analyzing its highest and lowest prices over a specified period. This endpoint returns data that includes pivot points, support levels, and resistance levels, which can be used to identify potential price reversal zones and optimize trade entry and exit strategies.
pub async fn get_time_series_pivot_points_hl(configuration: &configuration::Configuration, params: GetTimeSeriesPivotPointsHlParams) -> Result<models::GetTimeSeriesPivotPointsHl200Response, Error<GetTimeSeriesPivotPointsHlError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/pivot_points_hl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesPivotPointsHl200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesPivotPointsHl200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesPivotPointsHlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Plus Directional Indicator endpoint (/plus_di) provides data on the strength of a security's upward price movement by calculating the Plus Directional Indicator (PLUS_DI). It returns a time series of PLUS_DI values, which can be used to assess the intensity of upward trends in a security's price over a specified period.
pub async fn get_time_series_plus_di(configuration: &configuration::Configuration, params: GetTimeSeriesPlusDiParams) -> Result<models::GetTimeSeriesPlusDi200Response, Error<GetTimeSeriesPlusDiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/plus_di", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesPlusDi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesPlusDi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesPlusDiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Plus Directional Movement (PLUS_DM) endpoint calculates the upward price movement of a financial security over a specified period. It returns numerical values representing the magnitude of upward price changes, which can be used to assess the strength of an uptrend. This data is essential for traders and analysts who need to evaluate the bullish momentum of a security.
pub async fn get_time_series_plus_dm(configuration: &configuration::Configuration, params: GetTimeSeriesPlusDmParams) -> Result<models::GetTimeSeriesPlusDm200Response, Error<GetTimeSeriesPlusDmError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/plus_dm", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesPlusDm200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesPlusDm200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesPlusDmError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Percentage Price Oscillator (PPO) endpoint calculates the percentage difference between two specified moving averages of a financial instrument's price. It returns data that includes the PPO values, which traders can use to identify potential trend reversals and generate trading signals.
pub async fn get_time_series_ppo(configuration: &configuration::Configuration, params: GetTimeSeriesPpoParams) -> Result<models::GetTimeSeriesPpo200Response, Error<GetTimeSeriesPpoError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_fast_period = params.fast_period;
    let p_query_slow_period = params.slow_period;
    let p_query_ma_type = params.ma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ppo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_period {
        req_builder = req_builder.query(&[("fast_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_period {
        req_builder = req_builder.query(&[("slow_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ma_type {
        req_builder = req_builder.query(&[("ma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesPpo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesPpo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesPpoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Rate of Change (ROC) endpoint calculates the percentage change in a security's price over a defined period, returning a time series of ROC values. This data helps users track momentum by showing how quickly prices are changing, which can be useful for identifying potential price movements.
pub async fn get_time_series_roc(configuration: &configuration::Configuration, params: GetTimeSeriesRocParams) -> Result<models::GetTimeSeriesRoc200Response, Error<GetTimeSeriesRocError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/roc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRoc200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRoc200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRocError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Rate of Change Percentage (ROCP) endpoint calculates and returns the percentage change in the price of a financial security over a user-defined period. This data helps users identify shifts in price momentum and potential trend reversals by providing a clear numerical representation of how much the price has increased or decreased in percentage terms.
pub async fn get_time_series_rocp(configuration: &configuration::Configuration, params: GetTimeSeriesRocpParams) -> Result<models::GetTimeSeriesRocp200Response, Error<GetTimeSeriesRocpError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/rocp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRocp200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRocp200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRocpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Rate of Change Ratio (ROCR) endpoint calculates and returns the ratio of a security's current price to its price from a specified number of periods ago. This data helps users track price momentum and identify potential trend reversals by providing a clear numerical value that reflects price changes over time.
pub async fn get_time_series_rocr(configuration: &configuration::Configuration, params: GetTimeSeriesRocrParams) -> Result<models::GetTimeSeriesRocr200Response, Error<GetTimeSeriesRocrError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/rocr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRocr200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRocr200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRocrError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Rate of Change Ratio 100 (ROCR100) endpoint calculates the percentage change in a security's price over a specified period, expressed as a ratio to 100. It returns data that highlights the momentum of the price movement and identifies potential trend reversals. This endpoint is useful for users looking to assess the strength and direction of a security's price trend over time.
pub async fn get_time_series_rocr100(configuration: &configuration::Configuration, params: GetTimeSeriesRocr100Params) -> Result<models::GetTimeSeriesRocr100200Response, Error<GetTimeSeriesRocr100Error>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/rocr100", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRocr100200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRocr100200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRocr100Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Relative Strength Index (RSI) endpoint provides data on the RSI values for a specified financial instrument over a given period. It returns a series of RSI values, which indicate the momentum of price movements and help identify potential overbought or oversold conditions. This data is useful for traders looking to assess the strength of price trends and anticipate possible trend reversals.
pub async fn get_time_series_rsi(configuration: &configuration::Configuration, params: GetTimeSeriesRsiParams) -> Result<models::GetTimeSeriesRsi200Response, Error<GetTimeSeriesRsiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/rsi", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRsi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRsi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRsiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Relative Volume endpoint (/rvol) provides a ratio comparing a security's current trading volume to its average volume over a specified period. This data helps users detect unusual trading activity and assess the strength of price movements, offering insights into potential market breakouts.
pub async fn get_time_series_rvol(configuration: &configuration::Configuration, params: GetTimeSeriesRvolParams) -> Result<models::GetTimeSeriesRvol200Response, Error<GetTimeSeriesRvolError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/rvol", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesRvol200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesRvol200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesRvolError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Parabolic Stop and Reverse (SAR) endpoint provides data on potential support and resistance levels for a specified security, using its price and time. This endpoint returns numerical values that help traders determine possible entry and exit points in their trading strategies.
pub async fn get_time_series_sar(configuration: &configuration::Configuration, params: GetTimeSeriesSarParams) -> Result<models::GetTimeSeriesSar200Response, Error<GetTimeSeriesSarError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_acceleration = params.acceleration;
    let p_query_maximum = params.maximum;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_acceleration {
        req_builder = req_builder.query(&[("acceleration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_maximum {
        req_builder = req_builder.query(&[("maximum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSar200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSar200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Parabolic SAR Extended (SAREXT) endpoint provides a customizable version of the Parabolic SAR indicator, which is used to identify potential entry and exit points in trading. Users can adjust parameters such as acceleration factors to tailor the indicator to specific trading strategies. The endpoint returns data points indicating potential trend reversals.
pub async fn get_time_series_sar_ext(configuration: &configuration::Configuration, params: GetTimeSeriesSarExtParams) -> Result<models::GetTimeSeriesSarExt200Response, Error<GetTimeSeriesSarExtError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_start_value = params.start_value;
    let p_query_offset_on_reverse = params.offset_on_reverse;
    let p_query_acceleration_limit_long = params.acceleration_limit_long;
    let p_query_acceleration_long = params.acceleration_long;
    let p_query_acceleration_max_long = params.acceleration_max_long;
    let p_query_acceleration_limit_short = params.acceleration_limit_short;
    let p_query_acceleration_short = params.acceleration_short;
    let p_query_acceleration_max_short = params.acceleration_max_short;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sarext", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_start_value {
        req_builder = req_builder.query(&[("start_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset_on_reverse {
        req_builder = req_builder.query(&[("offset_on_reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_limit_long {
        req_builder = req_builder.query(&[("acceleration_limit_long", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_long {
        req_builder = req_builder.query(&[("acceleration_long", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_max_long {
        req_builder = req_builder.query(&[("acceleration_max_long", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_limit_short {
        req_builder = req_builder.query(&[("acceleration_limit_short", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_short {
        req_builder = req_builder.query(&[("acceleration_short", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_acceleration_max_short {
        req_builder = req_builder.query(&[("acceleration_max_short", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSarExt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSarExt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSarExtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Simple Moving Average (SMA) endpoint calculates and returns the average price of a security over a user-defined time period. This endpoint provides a series of data points that represent the smoothed price trend, which can help users identify potential price movements and evaluate historical price behavior.
pub async fn get_time_series_sma(configuration: &configuration::Configuration, params: GetTimeSeriesSmaParams) -> Result<models::GetTimeSeriesSma200Response, Error<GetTimeSeriesSmaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sma", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSma200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSma200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSmaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Square Root (SQRT) endpoint computes the square root of a specified numerical input. It returns a single numerical value representing the square root, which can be used in various mathematical computations or financial models requiring this specific transformation.
pub async fn get_time_series_sqrt(configuration: &configuration::Configuration, params: GetTimeSeriesSqrtParams) -> Result<models::GetTimeSeriesSqrt200Response, Error<GetTimeSeriesSqrtError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sqrt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSqrt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSqrt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSqrtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Standard Deviation (STDDEV) endpoint calculates the dispersion of a financial instrument's price data from its average value. It returns a numerical value representing the volatility of the asset over a specified period. This endpoint is useful for traders and analysts to assess price variability and identify periods of high or low volatility in the market.
pub async fn get_time_series_std_dev(configuration: &configuration::Configuration, params: GetTimeSeriesStdDevParams) -> Result<models::GetTimeSeriesStdDev200Response, Error<GetTimeSeriesStdDevError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_sd = params.sd;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/stddev", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sd {
        req_builder = req_builder.query(&[("sd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesStdDev200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesStdDev200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesStdDevError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Stochastic Oscillator endpoint provides data on a momentum indicator that evaluates a security's closing price relative to its price range over a specified timeframe. It returns values indicating potential overbought or oversold conditions, aiding in identifying possible trend reversals. Users receive the %K and %D values, which are essential for analyzing the momentum and potential turning points in the market.
pub async fn get_time_series_stoch(configuration: &configuration::Configuration, params: GetTimeSeriesStochParams) -> Result<models::GetTimeSeriesStoch200Response, Error<GetTimeSeriesStochError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_fast_k_period = params.fast_k_period;
    let p_query_slow_k_period = params.slow_k_period;
    let p_query_slow_d_period = params.slow_d_period;
    let p_query_slow_kma_type = params.slow_kma_type;
    let p_query_slow_dma_type = params.slow_dma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/stoch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_k_period {
        req_builder = req_builder.query(&[("fast_k_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_k_period {
        req_builder = req_builder.query(&[("slow_k_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_d_period {
        req_builder = req_builder.query(&[("slow_d_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_kma_type {
        req_builder = req_builder.query(&[("slow_kma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_slow_dma_type {
        req_builder = req_builder.query(&[("slow_dma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesStoch200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesStoch200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesStochError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Stochastic Fast (STOCHF) endpoint calculates the fast version of the Stochastic Oscillator, providing data on the momentum of a financial instrument by comparing a particular closing price to a range of its prices over a specified period. This endpoint returns the %K and %D values, which are used to identify potential overbought or oversold conditions in the market. It is useful for traders who need quick, responsive insights into price movements, although it may generate more false signals due to its sensitivity.
pub async fn get_time_series_stoch_f(configuration: &configuration::Configuration, params: GetTimeSeriesStochFParams) -> Result<models::GetTimeSeriesStochF200Response, Error<GetTimeSeriesStochFError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_fast_k_period = params.fast_k_period;
    let p_query_fast_d_period = params.fast_d_period;
    let p_query_fast_dma_type = params.fast_dma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/stochf", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_fast_k_period {
        req_builder = req_builder.query(&[("fast_k_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fast_d_period {
        req_builder = req_builder.query(&[("fast_d_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fast_dma_type {
        req_builder = req_builder.query(&[("fast_dma_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesStochF200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesStochF200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesStochFError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Stochastic Relative Strength Index (Stochastic RSI) endpoint calculates the Stochastic RSI values for a given financial instrument, providing data on its momentum and potential price reversals. This endpoint returns time-series data, including the %K and %D lines, which help users identify overbought or oversold conditions. Ideal for traders seeking to refine entry and exit points by analyzing short-term price movements.
pub async fn get_time_series_stoch_rsi(configuration: &configuration::Configuration, params: GetTimeSeriesStochRsiParams) -> Result<models::GetTimeSeriesStochRsi200Response, Error<GetTimeSeriesStochRsiError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_rsi_length = params.rsi_length;
    let p_query_stoch_length = params.stoch_length;
    let p_query_k_period = params.k_period;
    let p_query_slow_kma_type = params.slow_kma_type;
    let p_query_d_period = params.d_period;
    let p_query_slow_dma_type = params.slow_dma_type;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/stochrsi", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_rsi_length {
        req_builder = req_builder.query(&[("rsi_length", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stoch_length {
        req_builder = req_builder.query(&[("stoch_length", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_k_period {
        req_builder = req_builder.query(&[("k_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_kma_type {
        req_builder = req_builder.query(&[("slow_kma_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_d_period {
        req_builder = req_builder.query(&[("d_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slow_dma_type {
        req_builder = req_builder.query(&[("slow_dma_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesStochRsi200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesStochRsi200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesStochRsiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Subtraction (SUB) endpoint calculates the difference between two input data series, such as technical indicators or price data. It returns a time series of the resulting values, allowing users to compare or normalize data by highlighting the variance between the two series.
pub async fn get_time_series_sub(configuration: &configuration::Configuration, params: GetTimeSeriesSubParams) -> Result<models::GetTimeSeriesSub200Response, Error<GetTimeSeriesSubError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type_1 = params.series_type_1;
    let p_query_series_type_2 = params.series_type_2;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sub", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_1 {
        req_builder = req_builder.query(&[("series_type_1", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type_2 {
        req_builder = req_builder.query(&[("series_type_2", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSub200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSub200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSubError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Summation (SUM) endpoint calculates the cumulative total of a specified data series over a defined time period. It returns a numerical value representing the sum, which can be used to track the aggregate value of financial data, such as stock prices or trading volumes, over time. This endpoint is useful for users needing to compute the total accumulation of a dataset for further analysis or reporting.
pub async fn get_time_series_sum(configuration: &configuration::Configuration, params: GetTimeSeriesSumParams) -> Result<models::GetTimeSeriesSum200Response, Error<GetTimeSeriesSumError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/sum", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSum200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSum200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSumError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Supertrend endpoint provides data on the Supertrend indicator, a tool used to identify potential buy and sell signals in trending markets. It returns values that indicate the current trend direction and potential reversal points based on price, time, and volatility. Users can leverage this data to pinpoint optimal entry and exit points for trades.
pub async fn get_time_series_super_trend(configuration: &configuration::Configuration, params: GetTimeSeriesSuperTrendParams) -> Result<models::GetTimeSeriesSuperTrend200Response, Error<GetTimeSeriesSuperTrendError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_period = params.period;
    let p_query_multiplier = params.multiplier;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/supertrend", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multiplier {
        req_builder = req_builder.query(&[("multiplier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSuperTrend200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSuperTrend200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSuperTrendError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Supertrend Heikin Ashi candles endpoint provides data combining Supertrend signals with Heikin Ashi candlestick patterns. It returns a series of data points indicating trend direction and smoothed price movements, useful for identifying potential buy or sell opportunities in trading.
pub async fn get_time_series_super_trend_heikin_ashi_candles(configuration: &configuration::Configuration, params: GetTimeSeriesSuperTrendHeikinAshiCandlesParams) -> Result<models::GetTimeSeriesSuperTrendHeikinAshiCandles200Response, Error<GetTimeSeriesSuperTrendHeikinAshiCandlesError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_period = params.period;
    let p_query_multiplier = params.multiplier;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/supertrend_heikinashicandles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multiplier {
        req_builder = req_builder.query(&[("multiplier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesSuperTrendHeikinAshiCandles200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesSuperTrendHeikinAshiCandles200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesSuperTrendHeikinAshiCandlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Triple Exponential Moving Average (T3MA) endpoint calculates a smoothed moving average using three exponential moving averages on price data. It returns a dataset that highlights price trends with reduced lag, offering precise trend analysis. This is useful for identifying trend direction and potential reversal points.
pub async fn get_time_series_t3ma(configuration: &configuration::Configuration, params: GetTimeSeriesT3maParams) -> Result<models::GetTimeSeriesT3ma200Response, Error<GetTimeSeriesT3maError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_v_factor = params.v_factor;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/t3ma", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_v_factor {
        req_builder = req_builder.query(&[("v_factor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesT3ma200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesT3ma200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesT3maError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The True Range (TRANGE) endpoint calculates the range of price movement for a specified period, providing a measure of market volatility. It returns data that includes the highest and lowest prices over the period, along with the closing price from the previous period. This information is useful for traders to assess market volatility and adjust their trading strategies accordingly.
pub async fn get_time_series_t_range(configuration: &configuration::Configuration, params: GetTimeSeriesTRangeParams) -> Result<models::GetTimeSeriesTRange200Response, Error<GetTimeSeriesTRangeError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/trange", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesTRange200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesTRange200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesTRangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Triple Exponential Moving Average (TEMA) endpoint calculates and returns the TEMA values for a specified financial instrument over a given time period. This endpoint provides a series of data points that smooth out price fluctuations by applying three layers of exponential moving averages, allowing users to identify and track underlying trends in the instrument's price movement.
pub async fn get_time_series_tema(configuration: &configuration::Configuration, params: GetTimeSeriesTemaParams) -> Result<models::GetTimeSeriesTema200Response, Error<GetTimeSeriesTemaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/tema", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesTema200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesTema200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesTemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Triangular Moving Average (TRIMA) endpoint calculates and returns the smoothed average price of a financial security over a specified period, with a focus on central data points. This endpoint provides a balanced view of price trends by applying a double smoothing process, making it useful for identifying underlying price patterns and reducing short-term fluctuations.
pub async fn get_time_series_trima(configuration: &configuration::Configuration, params: GetTimeSeriesTrimaParams) -> Result<models::GetTimeSeriesTrima200Response, Error<GetTimeSeriesTrimaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/trima", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesTrima200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesTrima200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesTrimaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Time Series Forecast (TSF) endpoint provides projected future price levels using linear regression analysis. It returns data that helps users identify potential support and resistance levels, as well as trend direction in a financial market. This endpoint is useful for traders seeking to anticipate price movements and adjust their strategies accordingly.
pub async fn get_time_series_tsf(configuration: &configuration::Configuration, params: GetTimeSeriesTsfParams) -> Result<models::GetTimeSeriesTsf200Response, Error<GetTimeSeriesTsfError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/tsf", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesTsf200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesTsf200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesTsfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Typical Price (TYPPRICE) endpoint calculates and returns the average of a financial instrument's high, low, and close prices for a given period. This endpoint provides a simplified metric that reflects the central tendency of price movements, useful for traders and analysts who need a straightforward view of price trends.
pub async fn get_time_series_typ_price(configuration: &configuration::Configuration, params: GetTimeSeriesTypPriceParams) -> Result<models::GetTimeSeriesTypPrice200Response, Error<GetTimeSeriesTypPriceError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/typprice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesTypPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesTypPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesTypPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Ultimate Oscillator endpoint (/ultosc) calculates a momentum oscillator that integrates short, intermediate, and long-term price movements to detect potential overbought or oversold conditions and possible trend reversals. It returns a time series of oscillator values, which can be used to assess market momentum and identify entry or exit points in trading strategies.
pub async fn get_time_series_ult_osc(configuration: &configuration::Configuration, params: GetTimeSeriesUltOscParams) -> Result<models::GetTimeSeriesUltOsc200Response, Error<GetTimeSeriesUltOscError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period_1 = params.time_period_1;
    let p_query_time_period_2 = params.time_period_2;
    let p_query_time_period_3 = params.time_period_3;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/ultosc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period_1 {
        req_builder = req_builder.query(&[("time_period_1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_time_period_2 {
        req_builder = req_builder.query(&[("time_period_2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_time_period_3 {
        req_builder = req_builder.query(&[("time_period_3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesUltOsc200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesUltOsc200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesUltOscError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Variance (VAR) endpoint calculates the statistical variance of a financial data series, providing a measure of how much the data points deviate from the average value. It returns a numerical value representing this dispersion, which can be used to assess the volatility of a security over a specified period. This information is crucial for traders and analysts who need to evaluate the risk associated with price fluctuations in the market.
pub async fn get_time_series_var(configuration: &configuration::Configuration, params: GetTimeSeriesVarParams) -> Result<models::GetTimeSeriesVar200Response, Error<GetTimeSeriesVarError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/var", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesVar200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesVar200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesVarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Volume Weighted Average Price (VWAP) endpoint provides the VWAP value for a specified stock or asset over a given time period. This indicator calculates the average price at which a security has traded throughout the day, based on both volume and price. It is useful for identifying the true average price of an asset, helping traders to assess the current price relative to the day's average.
pub async fn get_time_series_vwap(configuration: &configuration::Configuration, params: GetTimeSeriesVwapParams) -> Result<models::GetTimeSeriesVwap200Response, Error<GetTimeSeriesVwapError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_sd_time_period = params.sd_time_period;
    let p_query_sd = params.sd;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/vwap", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sd_time_period {
        req_builder = req_builder.query(&[("sd_time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sd {
        req_builder = req_builder.query(&[("sd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesVwap200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesVwap200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesVwapError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Weighted Close Price (WCLPRICE) endpoint calculates a security's average price by giving additional weight to the closing price, using the formula: (High + Low + Close * 2) / 4.
pub async fn get_time_series_wcl_price(configuration: &configuration::Configuration, params: GetTimeSeriesWclPriceParams) -> Result<models::GetTimeSeriesWclPrice200Response, Error<GetTimeSeriesWclPriceError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/wclprice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesWclPrice200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesWclPrice200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesWclPriceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Williams %R (WILLR) endpoint calculates the Williams Percent Range, a momentum indicator that evaluates a security's closing price relative to its high-low range over a specified period. This endpoint returns data that helps users identify potential overbought or oversold conditions and possible trend reversals in the market.
pub async fn get_time_series_will_r(configuration: &configuration::Configuration, params: GetTimeSeriesWillRParams) -> Result<models::GetTimeSeriesWillR200Response, Error<GetTimeSeriesWillRError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/willr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesWillR200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesWillR200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesWillRError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Weighted Moving Average (WMA) endpoint calculates and returns the WMA values for a given security over a specified period. This endpoint provides a time series of weighted averages, where recent prices have a higher influence, allowing users to track and analyze short-term price trends effectively.
pub async fn get_time_series_wma(configuration: &configuration::Configuration, params: GetTimeSeriesWmaParams) -> Result<models::GetTimeSeriesWma200Response, Error<GetTimeSeriesWmaError>> {
    // Extract parameters from params struct
    let p_query_interval = params.interval;
    let p_query_symbol = params.symbol;
    let p_query_isin = params.isin;
    let p_query_figi = params.figi;
    let p_query_cusip = params.cusip;
    let p_query_outputsize = params.outputsize;
    let p_query_exchange = params.exchange;
    let p_query_mic_code = params.mic_code;
    let p_query_country = params.country;
    let p_query_type = params.r#type;
    let p_query_timezone = params.timezone;
    let p_query_start_date = params.start_date;
    let p_query_end_date = params.end_date;
    let p_query_date = params.date;
    let p_query_order = params.order;
    let p_query_prepost = params.prepost;
    let p_query_format = params.format;
    let p_query_delimiter = params.delimiter;
    let p_query_dp = params.dp;
    let p_query_previous_close = params.previous_close;
    let p_query_adjust = params.adjust;
    let p_query_series_type = params.series_type;
    let p_query_time_period = params.time_period;
    let p_query_include_ohlc = params.include_ohlc;

    let uri_str = format!("{}/wma", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isin {
        req_builder = req_builder.query(&[("isin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_figi {
        req_builder = req_builder.query(&[("figi", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cusip {
        req_builder = req_builder.query(&[("cusip", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("interval", &p_query_interval.to_string())]);
    if let Some(ref param_value) = p_query_outputsize {
        req_builder = req_builder.query(&[("outputsize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mic_code {
        req_builder = req_builder.query(&[("mic_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_prepost {
        req_builder = req_builder.query(&[("prepost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_delimiter {
        req_builder = req_builder.query(&[("delimiter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dp {
        req_builder = req_builder.query(&[("dp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_previous_close {
        req_builder = req_builder.query(&[("previous_close", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_adjust {
        req_builder = req_builder.query(&[("adjust", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_series_type {
        req_builder = req_builder.query(&[("series_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_time_period {
        req_builder = req_builder.query(&[("time_period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_ohlc {
        req_builder = req_builder.query(&[("include_ohlc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeSeriesWma200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeSeriesWma200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeSeriesWmaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

